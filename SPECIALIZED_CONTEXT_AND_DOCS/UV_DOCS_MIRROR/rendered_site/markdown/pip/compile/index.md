# [Locking environments](#locking-environments)

Locking is to take a dependency, e.g., `ruff `, and write an exact version to use to a file. When working with many dependencies, it is useful to lock the exact versions so the environment can be reproduced. Without locking, the versions of dependencies could change over time, when using a different tool, or across platforms. 

## [Locking requirements](#locking-requirements)

uv allows dependencies to be locked in the `requirements.txt `format. It is recommended to use the standard `pyproject.toml `to define dependencies, but other dependency formats are supported as well. See the documentation on [declaring dependencies](../dependencies/)for more details on how to define dependencies. 

To lock dependencies declared in a `pyproject.toml `: 

```
[#__codelineno-0-1](#__codelineno-0-1)$ uv pip compile pyproject.toml -o requirements.txt

```

Note by default the `uv pip compile `output is just displayed and `--output-file `/ `-o `argument is needed to write to a file. 

To lock dependencies declared in a `requirements.in `: 

```
[#__codelineno-1-1](#__codelineno-1-1)$ uv pip compile requirements.in -o requirements.txt

```

To lock dependencies declared in multiple files: 

```
[#__codelineno-2-1](#__codelineno-2-1)$ uv pip compile pyproject.toml requirements-dev.in -o requirements-dev.txt

```

uv also supports legacy `setup.py `and `setup.cfg `formats. To lock dependencies declared in a `setup.py `: 

```
[#__codelineno-3-1](#__codelineno-3-1)$ uv pip compile setup.py -o requirements.txt

```

To lock dependencies from stdin, use `- `: 

```
[#__codelineno-4-1](#__codelineno-4-1)$ echo "ruff" | uv pip compile -

```

To lock with optional dependencies enabled, e.g., the "foo" extra: 

```
[#__codelineno-5-1](#__codelineno-5-1)$ uv pip compile pyproject.toml --extra foo

```

To lock with all optional dependencies enabled: 

```
[#__codelineno-6-1](#__codelineno-6-1)$ uv pip compile pyproject.toml --all-extras

```

Note extras are not supported with the `requirements.in `format. 

To lock a dependency group in the current project directory's `pyproject.toml `, for example the group `foo `: 

```
[#__codelineno-7-1](#__codelineno-7-1)$ uv pip compile --group foo

```

!!! important "Important"

    A `--group `flag has to be added to pip-tools' `pip compile `, [although they're considering it](https://github.com/jazzband/pip-tools/issues/2062). We expect to support whatever syntax and semantics they adopt. 

To specify the project directory where groups should be sourced from: 

```
[#__codelineno-8-1](#__codelineno-8-1)$ uv pip compile --project some/path/ --group foo --group bar

```

Alternatively, you can specify a path to a `pyproject.toml `for each group: 

```
[#__codelineno-9-1](#__codelineno-9-1)$ uv pip compile --group some/path/pyproject.toml:foo --group other/pyproject.toml:bar

```

!!! note "Note"

    `--group `flags do not apply to other specified sources. For instance, `uv pip compile some/path/pyproject.toml --group foo `sources `foo `from `./pyproject.toml `and **not **`some/path/pyproject.toml `. 

## [Upgrading requirements](#upgrading-requirements)

When using an output file, uv will consider the versions pinned in an existing output file. If a dependency is pinned it will not be upgraded on a subsequent compile run. For example: 

```
[#__codelineno-10-1](#__codelineno-10-1)$ echo "ruff==0.3.0" > requirements.txt
[#__codelineno-10-2](#__codelineno-10-2)$ echo "ruff" | uv pip compile - -o requirements.txt
[#__codelineno-10-3](#__codelineno-10-3)# This file was autogenerated by uv via the following command:
[#__codelineno-10-4](#__codelineno-10-4)#    uv pip compile - -o requirements.txt
[#__codelineno-10-5](#__codelineno-10-5)ruff==0.3.0

```

To upgrade a dependency, use the `--upgrade-package `flag: 

```
[#__codelineno-11-1](#__codelineno-11-1)$ uv pip compile - -o requirements.txt --upgrade-package ruff

```

To upgrade all dependencies, there is an `--upgrade `flag. 

## [Syncing an environment](#syncing-an-environment)

Dependencies can be installed directly from their definition files or from compiled `requirements.txt `files with `uv pip install `. See the documentation on [installing packages from files](../packages/#installing-packages-from-files)for more details. 

When installing with `uv pip install `, packages that are already installed will not be removed unless they conflict with the lockfile. This means that the environment can have dependencies that aren't declared in the lockfile, which isn't great for reproducibility. To ensure the environment exactly matches the lockfile, use `uv pip sync `instead. 

To sync an environment with a `requirements.txt `file: 

```
[#__codelineno-12-1](#__codelineno-12-1)$ uv pip sync requirements.txt

```

To sync an environment with a [PEP 751](https://peps.python.org/pep-0751/)`pylock.toml `file: 

```
[#__codelineno-13-1](#__codelineno-13-1)$ uv pip sync pylock.toml

```

## [Adding constraints](#adding-constraints)

Constraints files are `requirements.txt `-like files that only control the _version _of a requirement that's installed. However, including a package in a constraints file will _not _trigger the installation of that package. Constraints can be used to add bounds to dependencies that are not dependencies of the current project. 

To define a constraint, define a bound for a package: 

constraints.txt 

```
[#__codelineno-14-1](#__codelineno-14-1)pydantic<2.0

```

To use a constraints file: 

```
[#__codelineno-15-1](#__codelineno-15-1)$ uv pip compile requirements.in --constraint constraints.txt

```

Note that multiple constraints can be defined in each file and multiple files can be used. 

uv will also read `constraint-dependencies `from the `pyproject.toml `at the workspace root, and append them to those specified in the constraints file. 

## [Adding build constraints](#adding-build-constraints)

Similar to `constraints `, but specifically for build-time dependencies, including those required when building runtime dependencies. 

Build constraint files are `requirements.txt `-like files that only control the _version _of a build-time requirement. However, including a package in a build constraints file will _not _trigger its installation at build time; instead, constraints apply only when the package is required as a direct or transitive build-time dependency. Build constraints can be used to add bounds to dependencies that are not explicitly declared as build-time dependencies of the current project. 

For example, if a package defines its build dependencies as follows: 

pyproject.toml 

```
[#__codelineno-16-1](#__codelineno-16-1)[build-system]
[#__codelineno-16-2](#__codelineno-16-2)requires = ["setuptools"]
[#__codelineno-16-3](#__codelineno-16-3)build-backend = "setuptools.build_meta"

```

Build constraints could be used to ensure that a specific version of `setuptools `is used for every package in the workspace: 

build-constraints.txt 

```
[#__codelineno-17-1](#__codelineno-17-1)setuptools==75.0.0

```

uv will also read `build-constraint-dependencies `from the `pyproject.toml `at the workspace root, and append them to those specified in the build constraints file. 

## [Overriding dependency versions](#overriding-dependency-versions)

Overrides files are `requirements.txt `-like files that force a specific version of a requirement to be installed, regardless of the requirements declared by any constituent package, and regardless of whether this would be considered an invalid resolution. 

While constraints are _additive _, in that they're combined with the requirements of the constituent packages, overrides are _absolute _, in that they completely replace the requirements of the constituent packages. 

Overrides are most often used to remove upper bounds from a transitive dependency. For example, if `a `requires `c>=1.0, < 2.0 `and `b `requires `c>=2.0 `and the current project requires `a `and `b `then the dependencies cannot be resolved. 

To define an override, define the new requirement for the problematic package: 

overrides.txt 

```
[#__codelineno-18-1](#__codelineno-18-1)c>=2.0

```

To use an overrides file: 

```
[#__codelineno-19-1](#__codelineno-19-1)$ uv pip compile requirements.in --override overrides.txt

```

Now, resolution can succeed. However, note that if `a `is _correct _that it does not support `c>=2.0 `then a runtime error will likely be encountered when using the packages. 

Note that multiple overrides can be defined in each file and multiple files can be used. 

July 8, 2025
