import{s as Et,o as Ft,n as _}from"../chunks/scheduler.18a86fab.js";import{S as qt,i as Nt,g,s as f,r as M,A as St,h as j,f as a,c,j as At,u as b,x as v,k as Bt,y as Ht,a as i,v as $,d as h,t as U,w as J}from"../chunks/index.98837b22.js";import{C as X}from"../chunks/CodeBlock.8d0c2e8a.js";import{H as Z,E as Lt}from"../chunks/getInferenceSnippets.06c2775f.js";import{H as xt,a as V}from"../chunks/HfOption.6641485e.js";function Yt(C){let l,d,s,y,u,o=`AutoRound also offer another two recipes, <code>auto-round-best</code> and <code>auto-round-light</code>, designed for optimal accuracy and improved speed, respectively.
For 2 bits, we recommend using <code>auto-round-best</code> or <code>auto-round</code>.`,p;return l=new Z({props:{title:"Command Line Usage",local:"command-line-usage",headingTag:"h3"}}),s=new X({props:{code:"YXV0by1yb3VuZCUyMCU1QyUwQSUyMCUyMCUyMCUyMC0tbW9kZWwlMjBmYWNlYm9vayUyRm9wdC0xMjVtJTIwJTVDJTBBJTIwJTIwJTIwJTIwLS1iaXRzJTIwNCUyMCU1QyUwQSUyMCUyMCUyMCUyMC0tZ3JvdXBfc2l6ZSUyMDEyOCUyMCU1QyUwQSUyMCUyMCUyMCUyMC0tb3V0cHV0X2RpciUyMC4lMkZ0bXBfYXV0b3JvdW5k",highlighted:`auto-round \\
    --model facebook/opt-125m \\
    --bits 4 \\
    --group_size 128 \\
    --output_dir ./tmp_autoround`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),M(s.$$.fragment),y=f(),u=g("p"),u.innerHTML=o},l(t){b(l.$$.fragment,t),d=c(t),b(s.$$.fragment,t),y=c(t),u=j(t,"P",{"data-svelte-h":!0}),v(u)!=="svelte-1e8c6p6"&&(u.innerHTML=o)},m(t,n){$(l,t,n),i(t,d,n),$(s,t,n),i(t,y,n),i(t,u,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(s.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(s.$$.fragment,t),p=!1},d(t){t&&(a(d),a(y),a(u)),J(l,t),J(s,t)}}}function Dt(C){let l,d,s,y="This setting offers a better trade-off between accuracy and tuning cost, and is recommended in all scenarios.",u,o,p;return l=new Z({props:{title:"AutoRound API Usage",local:"autoround-api-usage",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQWZyb20lMjBhdXRvX3JvdW5kJTIwaW1wb3J0JTIwQXV0b1JvdW5kJTBBJTBBbW9kZWxfbmFtZSUyMCUzRCUyMCUyMmZhY2Vib29rJTJGb3B0LTEyNW0lMjIlMEFtb2RlbCUyMCUzRCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lJTJDJTIwZHR5cGUlM0QlMjJhdXRvJTIyKSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUpJTBBYml0cyUyQyUyMGdyb3VwX3NpemUlMkMlMjBzeW0lMjAlM0QlMjA0JTJDJTIwMTI4JTJDJTIwVHJ1ZSUwQSUyMyUyMG1peGVkJTIwYml0cyUyMGNvbmZpZyUwQSUyMyUyMGxheWVyX2NvbmZpZyUyMCUzRCUyMCU3QiUyMm1vZGVsLmRlY29kZXIubGF5ZXJzLjYuc2VsZl9hdHRuLm91dF9wcm9qJTIyJTNBJTIwJTdCJTIyYml0cyUyMiUzQSUyMDIlMkMlMjAlMjJncm91cF9zaXplJTIyJTNBJTIwMzIlN0QlN0QlMEFhdXRvcm91bmQlMjAlM0QlMjBBdXRvUm91bmQoJTBBJTIwJTIwJTIwJTIwbW9kZWwlMkMlMEElMjAlMjAlMjAlMjB0b2tlbml6ZXIlMkMlMEElMjAlMjAlMjAlMjBiaXRzJTNEYml0cyUyQyUwQSUyMCUyMCUyMCUyMGdyb3VwX3NpemUlM0Rncm91cF9zaXplJTJDJTBBJTIwJTIwJTIwJTIwc3ltJTNEc3ltJTJDJTBBJTIwJTIwJTIwJTIwJTIzJTIwZW5hYmxlX3RvcmNoX2NvbXBpbGUlM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwJTIzJTIwbGF5ZXJfY29uZmlnJTNEbGF5ZXJfY29uZmlnJTJDJTBBKSUwQSUwQW91dHB1dF9kaXIlMjAlM0QlMjAlMjIuJTJGdG1wX2F1dG9yb3VuZCUyMiUwQSUyMyUyMGZvcm1hdCUzRCUyMCdhdXRvX3JvdW5kJyhkZWZhdWx0KSUyQyUyMCdhdXRvX2dwdHEnJTJDJTIwJ2F1dG9fYXdxJyUwQWF1dG9yb3VuZC5xdWFudGl6ZV9hbmRfc2F2ZShvdXRwdXRfZGlyJTJDJTIwZm9ybWF0JTNEJ2F1dG9fcm91bmQnKSUyMA==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer
<span class="hljs-keyword">from</span> auto_round <span class="hljs-keyword">import</span> AutoRound

model_name = <span class="hljs-string">&quot;facebook/opt-125m&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
bits, group_size, sym = <span class="hljs-number">4</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">True</span>
<span class="hljs-comment"># mixed bits config</span>
<span class="hljs-comment"># layer_config = {&quot;model.decoder.layers.6.self_attn.out_proj&quot;: {&quot;bits&quot;: 2, &quot;group_size&quot;: 32}}</span>
autoround = AutoRound(
    model,
    tokenizer,
    bits=bits,
    group_size=group_size,
    sym=sym,
    <span class="hljs-comment"># enable_torch_compile=True,</span>
    <span class="hljs-comment"># layer_config=layer_config,</span>
)

output_dir = <span class="hljs-string">&quot;./tmp_autoround&quot;</span>
<span class="hljs-comment"># format= &#x27;auto_round&#x27;(default), &#x27;auto_gptq&#x27;, &#x27;auto_awq&#x27;</span>
autoround.quantize_and_save(output_dir, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;auto_round&#x27;</span>) `,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-yupn8l"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function Pt(C){let l,d,s,y="This setting provides the best accuracy in most scenarios but is 4–5× slower than the standard AutoRound recipe. It is especially recommended for 2-bit quantization and is a good choice if sufficient resources are available.",u,o,p;return l=new Z({props:{title:"AutoRoundBest recipe",local:"autoroundbest-recipe",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQWZyb20lMjBhdXRvX3JvdW5kJTIwaW1wb3J0JTIwQXV0b1JvdW5kJTBBJTBBbW9kZWxfbmFtZSUyMCUzRCUyMCUyMmZhY2Vib29rJTJGb3B0LTEyNW0lMjIlMEFtb2RlbCUyMCUzRCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lJTJDJTIwZHR5cGUlM0QlMjJhdXRvJTIyKSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUpJTBBYml0cyUyQyUyMGdyb3VwX3NpemUlMkMlMjBzeW0lMjAlM0QlMjA0JTJDJTIwMTI4JTJDJTIwVHJ1ZSUwQWF1dG9yb3VuZCUyMCUzRCUyMEF1dG9Sb3VuZCglMEElMjAlMjAlMjAlMjBtb2RlbCUyQyUwQSUyMCUyMCUyMCUyMHRva2VuaXplciUyQyUwQSUyMCUyMCUyMCUyMGJpdHMlM0RiaXRzJTJDJTBBJTIwJTIwJTIwJTIwZ3JvdXBfc2l6ZSUzRGdyb3VwX3NpemUlMkMlMEElMjAlMjAlMjAlMjBzeW0lM0RzeW0lMkMlMEElMjAlMjAlMjAlMjBuc2FtcGxlcyUzRDUxMiUyQyUwQSUyMCUyMCUyMCUyMGl0ZXJzJTNEMTAwMCUyQyUwQSUyMCUyMCUyMCUyMGxvd19ncHVfbWVtX3VzYWdlJTNEVHJ1ZSUwQSklMEElMEFvdXRwdXRfZGlyJTIwJTNEJTIwJTIyLiUyRnRtcF9hdXRvcm91bmQlMjIlMEFhdXRvcm91bmQucXVhbnRpemVfYW5kX3NhdmUob3V0cHV0X2RpciUyQyUyMGZvcm1hdCUzRCdhdXRvX3JvdW5kJyklMjA=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer
<span class="hljs-keyword">from</span> auto_round <span class="hljs-keyword">import</span> AutoRound

model_name = <span class="hljs-string">&quot;facebook/opt-125m&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
bits, group_size, sym = <span class="hljs-number">4</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">True</span>
autoround = AutoRound(
    model,
    tokenizer,
    bits=bits,
    group_size=group_size,
    sym=sym,
    nsamples=<span class="hljs-number">512</span>,
    iters=<span class="hljs-number">1000</span>,
    low_gpu_mem_usage=<span class="hljs-literal">True</span>
)

output_dir = <span class="hljs-string">&quot;./tmp_autoround&quot;</span>
autoround.quantize_and_save(output_dir, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;auto_round&#x27;</span>) `,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-10hjd53"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function Kt(C){let l,d,s,y="This setting offers the best speed (2 - 3X faster than AutoRound), but it may cause a significant accuracy drop for small models and 2-bit quantization. It is recommended for 4-bit settings and models larger than 3B.",u,o,p;return l=new Z({props:{title:"AutoRoundLight recipe",local:"autoroundlight-recipe",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQWZyb20lMjBhdXRvX3JvdW5kJTIwaW1wb3J0JTIwQXV0b1JvdW5kJTBBJTBBbW9kZWxfbmFtZSUyMCUzRCUyMCUyMmZhY2Vib29rJTJGb3B0LTEyNW0lMjIlMEFtb2RlbCUyMCUzRCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lJTJDJTIwZHR5cGUlM0QlMjJhdXRvJTIyKSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUpJTBBYml0cyUyQyUyMGdyb3VwX3NpemUlMkMlMjBzeW0lMjAlM0QlMjA0JTJDJTIwMTI4JTJDJTIwVHJ1ZSUwQWF1dG9yb3VuZCUyMCUzRCUyMEF1dG9Sb3VuZCglMEElMjAlMjAlMjAlMjBtb2RlbCUyQyUwQSUyMCUyMCUyMCUyMHRva2VuaXplciUyQyUwQSUyMCUyMCUyMCUyMGJpdHMlM0RiaXRzJTJDJTBBJTIwJTIwJTIwJTIwZ3JvdXBfc2l6ZSUzRGdyb3VwX3NpemUlMkMlMEElMjAlMjAlMjAlMjBzeW0lM0RzeW0lMkMlMEElMjAlMjAlMjAlMjBpdGVycyUzRDUwJTJDJTBBJTIwJTIwJTIwJTIwbHIlM0Q1ZS0zJTJDJTBBKSUwQSUwQW91dHB1dF9kaXIlMjAlM0QlMjAlMjIuJTJGdG1wX2F1dG9yb3VuZCUyMiUwQWF1dG9yb3VuZC5xdWFudGl6ZV9hbmRfc2F2ZShvdXRwdXRfZGlyJTJDJTIwZm9ybWF0JTNEJ2F1dG9fcm91bmQnKSUyMA==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer
<span class="hljs-keyword">from</span> auto_round <span class="hljs-keyword">import</span> AutoRound

model_name = <span class="hljs-string">&quot;facebook/opt-125m&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
bits, group_size, sym = <span class="hljs-number">4</span>, <span class="hljs-number">128</span>, <span class="hljs-literal">True</span>
autoround = AutoRound(
    model,
    tokenizer,
    bits=bits,
    group_size=group_size,
    sym=sym,
    iters=<span class="hljs-number">50</span>,
    lr=<span class="hljs-number">5e-3</span>,
)

output_dir = <span class="hljs-string">&quot;./tmp_autoround&quot;</span>
autoround.quantize_and_save(output_dir, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;auto_round&#x27;</span>) `,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-xsq8gh"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function Ot(C){let l,d,s,y,u,o,p,t;return l=new V({props:{id:"quantization",option:"quantization cmd",$$slots:{default:[Yt]},$$scope:{ctx:C}}}),s=new V({props:{id:"quantization",option:"quantization auto-round api",$$slots:{default:[Dt]},$$scope:{ctx:C}}}),u=new V({props:{id:"quantization",option:"quantization auto-round-best",$$slots:{default:[Pt]},$$scope:{ctx:C}}}),p=new V({props:{id:"quantization",option:"quantization auto-round-light",$$slots:{default:[Kt]},$$scope:{ctx:C}}}),{c(){M(l.$$.fragment),d=f(),M(s.$$.fragment),y=f(),M(u.$$.fragment),o=f(),M(p.$$.fragment)},l(n){b(l.$$.fragment,n),d=c(n),b(s.$$.fragment,n),y=c(n),b(u.$$.fragment,n),o=c(n),b(p.$$.fragment,n)},m(n,T){$(l,n,T),i(n,d,T),$(s,n,T),i(n,y,T),$(u,n,T),i(n,o,T),$(p,n,T),t=!0},p(n,T){const r={};T&2&&(r.$$scope={dirty:T,ctx:n}),l.$set(r);const w={};T&2&&(w.$$scope={dirty:T,ctx:n}),s.$set(w);const R={};T&2&&(R.$$scope={dirty:T,ctx:n}),u.$set(R);const W={};T&2&&(W.$$scope={dirty:T,ctx:n}),p.$set(W)},i(n){t||(h(l.$$.fragment,n),h(s.$$.fragment,n),h(u.$$.fragment,n),h(p.$$.fragment,n),t=!0)},o(n){U(l.$$.fragment,n),U(s.$$.fragment,n),U(u.$$.fragment,n),U(p.$$.fragment,n),t=!1},d(n){n&&(a(d),a(y),a(o)),J(l,n),J(s,n),J(u,n),J(p,n)}}}function te(C){let l,d,s,y="Supports 2, 4, and 8 bits. We recommend using intel-extension-for-pytorch (IPEX) for 4 bits inference.",u,o,p;return l=new Z({props:{title:"CPU",local:"cpu",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQSUwQW1vZGVsX25hbWUlMjAlM0QlMjAlMjJPUEVBJTJGUXdlbjIuNS0xLjVCLUluc3RydWN0LWludDQtc3ltLWluYyUyMiUwQW1vZGVsJTIwJTNEJTIwQXV0b01vZGVsRm9yQ2F1c2FsTE0uZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUlMkMlMjBkZXZpY2VfbWFwJTNEJTIyY3B1JTIyJTJDJTIwZHR5cGUlM0QlMjJhdXRvJTIyKSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUpJTBBdGV4dCUyMCUzRCUyMCUyMlRoZXJlJTIwaXMlMjBhJTIwZ2lybCUyMHdobyUyMGxpa2VzJTIwYWR2ZW50dXJlJTJDJTIyJTBBaW5wdXRzJTIwJTNEJTIwdG9rZW5pemVyKHRleHQlMkMlMjByZXR1cm5fdGVuc29ycyUzRCUyMnB0JTIyKS50byhtb2RlbC5kZXZpY2UpJTBBcHJpbnQodG9rZW5pemVyLmRlY29kZShtb2RlbC5nZW5lcmF0ZSgqKmlucHV0cyUyQyUyMG1heF9uZXdfdG9rZW5zJTNENTAlMkMlMjBkb19zYW1wbGUlM0RGYWxzZSklNUIwJTVEKSk=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer

model_name = <span class="hljs-string">&quot;OPEA/Qwen2.5-1.5B-Instruct-int4-sym-inc&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;cpu&quot;</span>, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
text = <span class="hljs-string">&quot;There is a girl who likes adventure,&quot;</span>
inputs = tokenizer(text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(model.device)
<span class="hljs-built_in">print</span>(tokenizer.decode(model.generate(**inputs, max_new_tokens=<span class="hljs-number">50</span>, do_sample=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]))`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-1y1v5tk"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function ee(C){let l,d,s,y="Supports 4 bits only. We recommend using intel-extension-for-pytorch (IPEX) for inference.",u,o,p;return l=new Z({props:{title:"XPU",local:"xpu",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQSUwQW1vZGVsX25hbWUlMjAlM0QlMjAlMjJPUEVBJTJGUXdlbjIuNS0xLjVCLUluc3RydWN0LWludDQtc3ltLWluYyUyMiUwQW1vZGVsJTIwJTNEJTIwQXV0b01vZGVsRm9yQ2F1c2FsTE0uZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUlMkMlMjBkZXZpY2VfbWFwJTNEJTIyeHB1JTIyJTJDJTIwZHR5cGUlM0QlMjJhdXRvJTIyKSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUpJTBBdGV4dCUyMCUzRCUyMCUyMlRoZXJlJTIwaXMlMjBhJTIwZ2lybCUyMHdobyUyMGxpa2VzJTIwYWR2ZW50dXJlJTJDJTIyJTBBaW5wdXRzJTIwJTNEJTIwdG9rZW5pemVyKHRleHQlMkMlMjByZXR1cm5fdGVuc29ycyUzRCUyMnB0JTIyKS50byhtb2RlbC5kZXZpY2UpJTBBcHJpbnQodG9rZW5pemVyLmRlY29kZShtb2RlbC5nZW5lcmF0ZSgqKmlucHV0cyUyQyUyMG1heF9uZXdfdG9rZW5zJTNENTAlMkMlMjBkb19zYW1wbGUlM0RGYWxzZSklNUIwJTVEKSk=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer

model_name = <span class="hljs-string">&quot;OPEA/Qwen2.5-1.5B-Instruct-int4-sym-inc&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;xpu&quot;</span>, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
text = <span class="hljs-string">&quot;There is a girl who likes adventure,&quot;</span>
inputs = tokenizer(text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(model.device)
<span class="hljs-built_in">print</span>(tokenizer.decode(model.generate(**inputs, max_new_tokens=<span class="hljs-number">50</span>, do_sample=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]))`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-s5inkn"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function ne(C){let l,d,s,y="Supports 2, 3, 4, and 8 bits. We recommend using GPTQModel for 4 and 8 bits inference.",u,o,p;return l=new Z({props:{title:"CUDA",local:"cuda",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQSUwQW1vZGVsX25hbWUlMjAlM0QlMjAlMjJPUEVBJTJGUXdlbjIuNS0xLjVCLUluc3RydWN0LWludDQtc3ltLWluYyUyMiUwQW1vZGVsJTIwJTNEJTIwQXV0b01vZGVsRm9yQ2F1c2FsTE0uZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUlMkMlMjBkZXZpY2VfbWFwJTNEJTIyY3VkYSUyMiUyQyUyMGR0eXBlJTNEJTIyYXV0byUyMiklMEF0b2tlbml6ZXIlMjAlM0QlMjBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lKSUwQXRleHQlMjAlM0QlMjAlMjJUaGVyZSUyMGlzJTIwYSUyMGdpcmwlMjB3aG8lMjBsaWtlcyUyMGFkdmVudHVyZSUyQyUyMiUwQWlucHV0cyUyMCUzRCUyMHRva2VuaXplcih0ZXh0JTJDJTIwcmV0dXJuX3RlbnNvcnMlM0QlMjJwdCUyMikudG8obW9kZWwuZGV2aWNlKSUwQXByaW50KHRva2VuaXplci5kZWNvZGUobW9kZWwuZ2VuZXJhdGUoKippbnB1dHMlMkMlMjBtYXhfbmV3X3Rva2VucyUzRDUwJTJDJTIwZG9fc2FtcGxlJTNERmFsc2UpJTVCMCU1RCkp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer

model_name = <span class="hljs-string">&quot;OPEA/Qwen2.5-1.5B-Instruct-int4-sym-inc&quot;</span>
model = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;cuda&quot;</span>, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
text = <span class="hljs-string">&quot;There is a girl who likes adventure,&quot;</span>
inputs = tokenizer(text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(model.device)
<span class="hljs-built_in">print</span>(tokenizer.decode(model.generate(**inputs, max_new_tokens=<span class="hljs-number">50</span>, do_sample=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]))`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-19kacz2"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function le(C){let l,d,s,y='AutoRound automatically selects the backend for each layer based on compatibility. In general, the priority order is Marlin &gt; ExLLaMAV2 &gt; Triton, but the final choice depends on factors such as group size, bit width, packing format, hardware device, and other implementation details. For more details, please refer to <a href="https://github.com/intel/auto-round?tab=readme-ov-file#specify-backend" rel="nofollow">backends</a>,',u,o,p=`The backend may not always be the most suitable for certain devices.
You can specify your preferred backend such as “ipex” for CPU, “ipex/triton” for XPU, “marlin/exllamav2/triton” for CUDA, according to your needs or hardware compatibility. Please note that additional corresponding libraries may be required.`,t,n,T;return l=new Z({props:{title:"Specify Inference Backend",local:"specify-inference-backend",headingTag:"h3"}}),n=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUyQyUyMEF1dG9Sb3VuZENvbmZpZyUwQSUwQW1vZGVsX25hbWUlMjAlM0QlMjAlMjJPUEVBJTJGUXdlbjIuNS0xLjVCLUluc3RydWN0LWludDQtc3ltLWluYyUyMiUwQXF1YW50aXphdGlvbl9jb25maWclMjAlM0QlMjBBdXRvUm91bmRDb25maWcoYmFja2VuZCUzRCUyMmlwZXglMjIpJTBBbW9kZWwlMjAlM0QlMjBBdXRvTW9kZWxGb3JDYXVzYWxMTS5mcm9tX3ByZXRyYWluZWQobW9kZWxfbmFtZSUyQyUyMGRldmljZV9tYXAlM0QlMjJjcHUlMjIlMkMlMjBxdWFudGl6YXRpb25fY29uZmlnJTNEcXVhbnRpemF0aW9uX2NvbmZpZyUyQyUyMGR0eXBlJTNEJTIyYXV0byUyMiklMEF0b2tlbml6ZXIlMjAlM0QlMjBBdXRvVG9rZW5pemVyLmZyb21fcHJldHJhaW5lZChtb2RlbF9uYW1lKSUwQXRleHQlMjAlM0QlMjAlMjJUaGVyZSUyMGlzJTIwYSUyMGdpcmwlMjB3aG8lMjBsaWtlcyUyMGFkdmVudHVyZSUyQyUyMiUwQWlucHV0cyUyMCUzRCUyMHRva2VuaXplcih0ZXh0JTJDJTIwcmV0dXJuX3RlbnNvcnMlM0QlMjJwdCUyMikudG8obW9kZWwuZGV2aWNlKSUwQXByaW50KHRva2VuaXplci5kZWNvZGUobW9kZWwuZ2VuZXJhdGUoKippbnB1dHMlMkMlMjBtYXhfbmV3X3Rva2VucyUzRDUwJTJDJTIwZG9fc2FtcGxlJTNERmFsc2UpJTVCMCU1RCkp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer, AutoRoundConfig

model_name = <span class="hljs-string">&quot;OPEA/Qwen2.5-1.5B-Instruct-int4-sym-inc&quot;</span>
quantization_config = AutoRoundConfig(backend=<span class="hljs-string">&quot;ipex&quot;</span>)
model = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;cpu&quot;</span>, quantization_config=quantization_config, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
text = <span class="hljs-string">&quot;There is a girl who likes adventure,&quot;</span>
inputs = tokenizer(text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(model.device)
<span class="hljs-built_in">print</span>(tokenizer.decode(model.generate(**inputs, max_new_tokens=<span class="hljs-number">50</span>, do_sample=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]))`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.innerHTML=y,u=f(),o=g("p"),o.textContent=p,t=f(),M(n.$$.fragment)},l(r){b(l.$$.fragment,r),d=c(r),s=j(r,"P",{"data-svelte-h":!0}),v(s)!=="svelte-1acy203"&&(s.innerHTML=y),u=c(r),o=j(r,"P",{"data-svelte-h":!0}),v(o)!=="svelte-1xivk5i"&&(o.textContent=p),t=c(r),b(n.$$.fragment,r)},m(r,w){$(l,r,w),i(r,d,w),i(r,s,w),i(r,u,w),i(r,o,w),i(r,t,w),$(n,r,w),T=!0},p:_,i(r){T||(h(l.$$.fragment,r),h(n.$$.fragment,r),T=!0)},o(r){U(l.$$.fragment,r),U(n.$$.fragment,r),T=!1},d(r){r&&(a(d),a(s),a(u),a(o),a(t)),J(l,r),J(n,r)}}}function se(C){let l,d,s,y="Most GPTQ/AWQ models can be converted to the AutoRound format for better compatibility and support with Intel devices. Please note that the quantization config will be changed if the model is serialized.",u,o,p;return l=new Z({props:{title:"Convert GPTQ/AWQ to AutoRound",local:"convert-gptqawq-to-autoround",headingTag:"h3"}}),o=new X({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUyQyUyMEF1dG9Sb3VuZENvbmZpZyUwQSUwQW1vZGVsX25hbWUlMjAlM0QlMjAlMjJ5YmVsa2FkYSUyRm9wdC0xMjVtLWdwdHEtNGJpdCUyMiUwQXF1YW50aXphdGlvbl9jb25maWclMjAlM0QlMjBBdXRvUm91bmRDb25maWcoKSUwQW1vZGVsJTIwJTNEJTIwQXV0b01vZGVsRm9yQ2F1c2FsTE0uZnJvbV9wcmV0cmFpbmVkKG1vZGVsX25hbWUlMkMlMjBkZXZpY2VfbWFwJTNEJTIyY3B1JTIyJTJDJTIwcXVhbnRpemF0aW9uX2NvbmZpZyUzRHF1YW50aXphdGlvbl9jb25maWclMkMlMjBkdHlwZSUzRCUyMmF1dG8lMjIpJTBBdG9rZW5pemVyJTIwJTNEJTIwQXV0b1Rva2VuaXplci5mcm9tX3ByZXRyYWluZWQobW9kZWxfbmFtZSklMEF0ZXh0JTIwJTNEJTIwJTIyVGhlcmUlMjBpcyUyMGElMjBnaXJsJTIwd2hvJTIwbGlrZXMlMjBhZHZlbnR1cmUlMkMlMjIlMEFpbnB1dHMlMjAlM0QlMjB0b2tlbml6ZXIodGV4dCUyQyUyMHJldHVybl90ZW5zb3JzJTNEJTIycHQlMjIpLnRvKG1vZGVsLmRldmljZSklMEFwcmludCh0b2tlbml6ZXIuZGVjb2RlKG1vZGVsLmdlbmVyYXRlKCoqaW5wdXRzJTJDJTIwbWF4X25ld190b2tlbnMlM0Q1MCUyQyUyMGRvX3NhbXBsZSUzREZhbHNlKSU1QjAlNUQpKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer, AutoRoundConfig

model_name = <span class="hljs-string">&quot;ybelkada/opt-125m-gptq-4bit&quot;</span>
quantization_config = AutoRoundConfig()
model = AutoModelForCausalLM.from_pretrained(model_name, device_map=<span class="hljs-string">&quot;cpu&quot;</span>, quantization_config=quantization_config, dtype=<span class="hljs-string">&quot;auto&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(model_name)
text = <span class="hljs-string">&quot;There is a girl who likes adventure,&quot;</span>
inputs = tokenizer(text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(model.device)
<span class="hljs-built_in">print</span>(tokenizer.decode(model.generate(**inputs, max_new_tokens=<span class="hljs-number">50</span>, do_sample=<span class="hljs-literal">False</span>)[<span class="hljs-number">0</span>]))`,wrap:!1}}),{c(){M(l.$$.fragment),d=f(),s=g("p"),s.textContent=y,u=f(),M(o.$$.fragment)},l(t){b(l.$$.fragment,t),d=c(t),s=j(t,"P",{"data-svelte-h":!0}),v(s)!=="svelte-3hyjlt"&&(s.textContent=y),u=c(t),b(o.$$.fragment,t)},m(t,n){$(l,t,n),i(t,d,n),i(t,s,n),i(t,u,n),$(o,t,n),p=!0},p:_,i(t){p||(h(l.$$.fragment,t),h(o.$$.fragment,t),p=!0)},o(t){U(l.$$.fragment,t),U(o.$$.fragment,t),p=!1},d(t){t&&(a(d),a(s),a(u)),J(l,t),J(o,t)}}}function ae(C){let l,d,s,y,u,o,p,t,n,T;return l=new V({props:{id:"inference",option:"inference cpu",$$slots:{default:[te]},$$scope:{ctx:C}}}),s=new V({props:{id:"inference",option:"inference xpu",$$slots:{default:[ee]},$$scope:{ctx:C}}}),u=new V({props:{id:"inference",option:"inference cuda",$$slots:{default:[ne]},$$scope:{ctx:C}}}),p=new V({props:{id:"inference",option:"inference backend",$$slots:{default:[le]},$$scope:{ctx:C}}}),n=new V({props:{id:"inference",option:"format convert",$$slots:{default:[se]},$$scope:{ctx:C}}}),{c(){M(l.$$.fragment),d=f(),M(s.$$.fragment),y=f(),M(u.$$.fragment),o=f(),M(p.$$.fragment),t=f(),M(n.$$.fragment)},l(r){b(l.$$.fragment,r),d=c(r),b(s.$$.fragment,r),y=c(r),b(u.$$.fragment,r),o=c(r),b(p.$$.fragment,r),t=c(r),b(n.$$.fragment,r)},m(r,w){$(l,r,w),i(r,d,w),$(s,r,w),i(r,y,w),$(u,r,w),i(r,o,w),$(p,r,w),i(r,t,w),$(n,r,w),T=!0},p(r,w){const R={};w&2&&(R.$$scope={dirty:w,ctx:r}),l.$set(R);const W={};w&2&&(W.$$scope={dirty:w,ctx:r}),s.$set(W);const z={};w&2&&(z.$$scope={dirty:w,ctx:r}),u.$set(z);const k={};w&2&&(k.$$scope={dirty:w,ctx:r}),p.$set(k);const Q={};w&2&&(Q.$$scope={dirty:w,ctx:r}),n.$set(Q)},i(r){T||(h(l.$$.fragment,r),h(s.$$.fragment,r),h(u.$$.fragment,r),h(p.$$.fragment,r),h(n.$$.fragment,r),T=!0)},o(r){U(l.$$.fragment,r),U(s.$$.fragment,r),U(u.$$.fragment,r),U(p.$$.fragment,r),U(n.$$.fragment,r),T=!1},d(r){r&&(a(d),a(y),a(o),a(t)),J(l,r),J(s,r),J(u,r),J(p,r),J(n,r)}}}function oe(C){let l,d,s,y,u,o,p,t=`<a href="https://github.com/intel/auto-round" rel="nofollow">AutoRound</a> is an advanced quantization algorithm that delivers strong accuracy, even at 2-bit precision.
It leverages sign gradient descent to fine-tune both rounding values and min-max clipping thresholds in just 200 steps. Designed for broad compatibility, it seamlessly supports a wide range of LLMs and is actively expanding to cover more VLMs as well.
It also supports quantization and inference across multiple hardware platforms, including CPU, XPU, and CUDA.`,n,T,r=`AutoRound also offers a variety of useful features, including mixed-bit tuning and inference, lm-head quantization, support for exporting to formats like GPTQ/AWQ/GGUF, and flexible tuning recipes.
For a comprehensive overview and the latest updates, check out the AutoRound <a href="https://github.com/intel/auto-round" rel="nofollow">README</a>.`,w,R,W=`AutoRound was originally developed as part of the <a href="https://github.com/intel/neural-compressor" rel="nofollow">Intel Neural Compressor</a>, serving as a general-purpose model compression library for deep learning.
It has since evolved into a standalone library focused specifically on low-precision optimization for large language models (LLMs).
AutoRound remains fully integrated with the Intel Neural Compressor, and you can explore the repository for more details.`,z,k,Q,A,at,B,ot,x,vt="AutoRound supports several quantization configurations:",it,E,Zt="<li><strong>Int8 Weight Only</strong></li> <li><strong>Int4 Weight Only</strong></li> <li><strong>Int3 Weight Only</strong></li> <li><strong>Int2 Weight Only</strong></li> <li><strong>Mixed bits Weight only</strong></li>",rt,F,ut,q,Rt="CPU, XPU, and CUDA for both quantization and inference.",pt,N,mt,S,kt="Currently, only offline mode is supported to generate quantized models.",dt,G,ft,H,Xt="W4G128 Average Accuracy of 13 tasks (mmlu-pro, if_eval, gsm8k, etc) and Time Cost Results (Testing was conducted on the Nvidia A100 80G using the version of PyTorch 2.6.0 with enable_torch_compile):",ct,L,Vt="<thead><tr><th>Model</th> <th>Qwen2.5-0.5B-Instruct</th> <th>Falcon3-3B</th> <th>Qwen2.5-7B-Instruct</th> <th>Meta-Llama-3.1-8B-Instruct</th> <th>Falcon3-10B</th> <th>Qwen2.5-72B-Instruct</th></tr></thead> <tbody><tr><td>16bits</td> <td>0.4192</td> <td>0.5203</td> <td>0.6470</td> <td>0.6212</td> <td>0.6151</td> <td>0.7229</td></tr> <tr><td>Best</td> <td><strong>0.4137</strong>(7m)</td> <td><strong>0.5142</strong>(23m)</td> <td>0.6426(58m)</td> <td><strong>0.6116</strong>(65m)</td> <td><strong>0.6092</strong>(81m)</td> <td>0.7242(575m)</td></tr> <tr><td>Default</td> <td>0.4129(2m)</td> <td>0.5133(6m)</td> <td>0.6441(13m)</td> <td>0.6106(13m)</td> <td>0.6080(18m)</td> <td><strong>0.7252</strong>(118m)</td></tr> <tr><td>Light</td> <td>0.4052(2m)</td> <td>0.5108(3m)</td> <td><strong>0.6453</strong>(5m)</td> <td>0.6104(6m)</td> <td>0.6063(6m)</td> <td>0.7243(37m)</td></tr></tbody>",yt,Y,Mt,D,_t="AutoRound automatically selects the best available backend based on the installed libraries and prompts the user to install additional libraries when a better backend is found.",bt,I,$t,P,ht,K,Wt=`If you encounter any issues with the transformers integration, please open an issue on
the <a href="https://github.com/huggingface/transformers/issues" rel="nofollow">transformers</a> repository.<br/>
If you encounter any issues with auto-round, please open an issue on
the <a href="https://github.com/intel/auto-round/issues" rel="nofollow">AutoRound</a> repository.`,Ut,O,Jt,tt,Gt="Special thanks to open-source low precision libraries such as AutoGPTQ, AutoAWQ, GPTQModel, Triton, Marlin, and ExLLaMAV2 for providing low-precision CUDA kernels, which are leveraged in AutoRound.",wt,et,Tt,nt,It=`Contributions to <a href="https://github.com/intel/auto-round/pulls" rel="nofollow">AutoRound</a> are welcome and greatly appreciated!
Whether it’s fixing bugs, improving documentation, adding new features, or suggesting improvements, your help is always valued.`,gt,lt,jt,st,Ct;return u=new Z({props:{title:"AutoRound",local:"autoround",headingTag:"h1"}}),k=new Z({props:{title:"Installation",local:"installation",headingTag:"h2"}}),A=new X({props:{code:"cGlwJTIwaW5zdGFsbCUyMGF1dG8tcm91bmQ=",highlighted:"pip install auto-round",wrap:!1}}),B=new Z({props:{title:"Supported Quantization Configurations",local:"supported-quantization-configurations",headingTag:"h2"}}),F=new Z({props:{title:"Hardware Compatibility",local:"hardware-compatibility",headingTag:"h2"}}),N=new Z({props:{title:"Quantization and Serialization (offline)",local:"quantization-and-serialization-offline",headingTag:"h2"}}),G=new xt({props:{id:"quantization",options:["quantization cmd","quantization auto-round api","quantization auto-round-best","quantization auto-round-light"],$$slots:{default:[Ot]},$$scope:{ctx:C}}}),Y=new Z({props:{title:"Inference",local:"inference",headingTag:"h2"}}),I=new xt({props:{id:"inference",options:["inference cpu","inference xpu","inference cuda","inference backend","format convert"],$$slots:{default:[ae]},$$scope:{ctx:C}}}),P=new Z({props:{title:"Issues",local:"issues",headingTag:"h2"}}),O=new Z({props:{title:"Acknowledgement",local:"acknowledgement",headingTag:"h2"}}),et=new Z({props:{title:"Contribution",local:"contribution",headingTag:"h2"}}),lt=new Lt({props:{source:"https://github.com/huggingface/transformers/blob/main/docs/source/en/quantization/auto_round.md"}}),{c(){l=g("meta"),d=f(),s=g("p"),y=f(),M(u.$$.fragment),o=f(),p=g("p"),p.innerHTML=t,n=f(),T=g("p"),T.innerHTML=r,w=f(),R=g("p"),R.innerHTML=W,z=f(),M(k.$$.fragment),Q=f(),M(A.$$.fragment),at=f(),M(B.$$.fragment),ot=f(),x=g("p"),x.textContent=vt,it=f(),E=g("ul"),E.innerHTML=Zt,rt=f(),M(F.$$.fragment),ut=f(),q=g("p"),q.textContent=Rt,pt=f(),M(N.$$.fragment),mt=f(),S=g("p"),S.textContent=kt,dt=f(),M(G.$$.fragment),ft=f(),H=g("p"),H.textContent=Xt,ct=f(),L=g("table"),L.innerHTML=Vt,yt=f(),M(Y.$$.fragment),Mt=f(),D=g("p"),D.textContent=_t,bt=f(),M(I.$$.fragment),$t=f(),M(P.$$.fragment),ht=f(),K=g("p"),K.innerHTML=Wt,Ut=f(),M(O.$$.fragment),Jt=f(),tt=g("p"),tt.textContent=Gt,wt=f(),M(et.$$.fragment),Tt=f(),nt=g("p"),nt.innerHTML=It,gt=f(),M(lt.$$.fragment),jt=f(),st=g("p"),this.h()},l(e){const m=St("svelte-u9bgzb",document.head);l=j(m,"META",{name:!0,content:!0}),m.forEach(a),d=c(e),s=j(e,"P",{}),At(s).forEach(a),y=c(e),b(u.$$.fragment,e),o=c(e),p=j(e,"P",{"data-svelte-h":!0}),v(p)!=="svelte-zfjosr"&&(p.innerHTML=t),n=c(e),T=j(e,"P",{"data-svelte-h":!0}),v(T)!=="svelte-1wz4dbq"&&(T.innerHTML=r),w=c(e),R=j(e,"P",{"data-svelte-h":!0}),v(R)!=="svelte-glkcnl"&&(R.innerHTML=W),z=c(e),b(k.$$.fragment,e),Q=c(e),b(A.$$.fragment,e),at=c(e),b(B.$$.fragment,e),ot=c(e),x=j(e,"P",{"data-svelte-h":!0}),v(x)!=="svelte-1516lzr"&&(x.textContent=vt),it=c(e),E=j(e,"UL",{"data-svelte-h":!0}),v(E)!=="svelte-aq57h4"&&(E.innerHTML=Zt),rt=c(e),b(F.$$.fragment,e),ut=c(e),q=j(e,"P",{"data-svelte-h":!0}),v(q)!=="svelte-1qo6qgm"&&(q.textContent=Rt),pt=c(e),b(N.$$.fragment,e),mt=c(e),S=j(e,"P",{"data-svelte-h":!0}),v(S)!=="svelte-urocl9"&&(S.textContent=kt),dt=c(e),b(G.$$.fragment,e),ft=c(e),H=j(e,"P",{"data-svelte-h":!0}),v(H)!=="svelte-rkgegv"&&(H.textContent=Xt),ct=c(e),L=j(e,"TABLE",{"data-svelte-h":!0}),v(L)!=="svelte-1p1mc9q"&&(L.innerHTML=Vt),yt=c(e),b(Y.$$.fragment,e),Mt=c(e),D=j(e,"P",{"data-svelte-h":!0}),v(D)!=="svelte-1qbpe2o"&&(D.textContent=_t),bt=c(e),b(I.$$.fragment,e),$t=c(e),b(P.$$.fragment,e),ht=c(e),K=j(e,"P",{"data-svelte-h":!0}),v(K)!=="svelte-1q719sq"&&(K.innerHTML=Wt),Ut=c(e),b(O.$$.fragment,e),Jt=c(e),tt=j(e,"P",{"data-svelte-h":!0}),v(tt)!=="svelte-fpent4"&&(tt.textContent=Gt),wt=c(e),b(et.$$.fragment,e),Tt=c(e),nt=j(e,"P",{"data-svelte-h":!0}),v(nt)!=="svelte-1sijxqp"&&(nt.innerHTML=It),gt=c(e),b(lt.$$.fragment,e),jt=c(e),st=j(e,"P",{}),At(st).forEach(a),this.h()},h(){Bt(l,"name","hf:doc:metadata"),Bt(l,"content",ie)},m(e,m){Ht(document.head,l),i(e,d,m),i(e,s,m),i(e,y,m),$(u,e,m),i(e,o,m),i(e,p,m),i(e,n,m),i(e,T,m),i(e,w,m),i(e,R,m),i(e,z,m),$(k,e,m),i(e,Q,m),$(A,e,m),i(e,at,m),$(B,e,m),i(e,ot,m),i(e,x,m),i(e,it,m),i(e,E,m),i(e,rt,m),$(F,e,m),i(e,ut,m),i(e,q,m),i(e,pt,m),$(N,e,m),i(e,mt,m),i(e,S,m),i(e,dt,m),$(G,e,m),i(e,ft,m),i(e,H,m),i(e,ct,m),i(e,L,m),i(e,yt,m),$(Y,e,m),i(e,Mt,m),i(e,D,m),i(e,bt,m),$(I,e,m),i(e,$t,m),$(P,e,m),i(e,ht,m),i(e,K,m),i(e,Ut,m),$(O,e,m),i(e,Jt,m),i(e,tt,m),i(e,wt,m),$(et,e,m),i(e,Tt,m),i(e,nt,m),i(e,gt,m),$(lt,e,m),i(e,jt,m),i(e,st,m),Ct=!0},p(e,[m]){const zt={};m&2&&(zt.$$scope={dirty:m,ctx:e}),G.$set(zt);const Qt={};m&2&&(Qt.$$scope={dirty:m,ctx:e}),I.$set(Qt)},i(e){Ct||(h(u.$$.fragment,e),h(k.$$.fragment,e),h(A.$$.fragment,e),h(B.$$.fragment,e),h(F.$$.fragment,e),h(N.$$.fragment,e),h(G.$$.fragment,e),h(Y.$$.fragment,e),h(I.$$.fragment,e),h(P.$$.fragment,e),h(O.$$.fragment,e),h(et.$$.fragment,e),h(lt.$$.fragment,e),Ct=!0)},o(e){U(u.$$.fragment,e),U(k.$$.fragment,e),U(A.$$.fragment,e),U(B.$$.fragment,e),U(F.$$.fragment,e),U(N.$$.fragment,e),U(G.$$.fragment,e),U(Y.$$.fragment,e),U(I.$$.fragment,e),U(P.$$.fragment,e),U(O.$$.fragment,e),U(et.$$.fragment,e),U(lt.$$.fragment,e),Ct=!1},d(e){e&&(a(d),a(s),a(y),a(o),a(p),a(n),a(T),a(w),a(R),a(z),a(Q),a(at),a(ot),a(x),a(it),a(E),a(rt),a(ut),a(q),a(pt),a(mt),a(S),a(dt),a(ft),a(H),a(ct),a(L),a(yt),a(Mt),a(D),a(bt),a($t),a(ht),a(K),a(Ut),a(Jt),a(tt),a(wt),a(Tt),a(nt),a(gt),a(jt),a(st)),a(l),J(u,e),J(k,e),J(A,e),J(B,e),J(F,e),J(N,e),J(G,e),J(Y,e),J(I,e),J(P,e),J(O,e),J(et,e),J(lt,e)}}}const ie='{"title":"AutoRound","local":"autoround","sections":[{"title":"Installation","local":"installation","sections":[],"depth":2},{"title":"Supported Quantization Configurations","local":"supported-quantization-configurations","sections":[],"depth":2},{"title":"Hardware Compatibility","local":"hardware-compatibility","sections":[],"depth":2},{"title":"Quantization and Serialization (offline)","local":"quantization-and-serialization-offline","sections":[{"title":"Command Line Usage","local":"command-line-usage","sections":[],"depth":3},{"title":"AutoRound API Usage","local":"autoround-api-usage","sections":[],"depth":3},{"title":"AutoRoundBest recipe","local":"autoroundbest-recipe","sections":[],"depth":3},{"title":"AutoRoundLight recipe","local":"autoroundlight-recipe","sections":[],"depth":3}],"depth":2},{"title":"Inference","local":"inference","sections":[{"title":"CPU","local":"cpu","sections":[],"depth":3},{"title":"XPU","local":"xpu","sections":[],"depth":3},{"title":"CUDA","local":"cuda","sections":[],"depth":3},{"title":"Specify Inference Backend","local":"specify-inference-backend","sections":[],"depth":3},{"title":"Convert GPTQ/AWQ to AutoRound","local":"convert-gptqawq-to-autoround","sections":[],"depth":3}],"depth":2},{"title":"Issues","local":"issues","sections":[],"depth":2},{"title":"Acknowledgement","local":"acknowledgement","sections":[],"depth":2},{"title":"Contribution","local":"contribution","sections":[],"depth":2}],"depth":1}';function re(C){return Ft(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ce extends qt{constructor(l){super(),Nt(this,l,re,oe,Et,{})}}export{ce as component};
