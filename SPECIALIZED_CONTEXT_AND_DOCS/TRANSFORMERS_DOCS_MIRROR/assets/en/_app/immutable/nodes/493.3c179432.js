import{s as gn,o as Mn,n as kt}from"../chunks/scheduler.18a86fab.js";import{S as bn,i as Tn,g as l,s,r as g,A as wn,h as o,f as n,c as i,j as hn,u as M,x as p,k as yn,y as Un,a,v as b,d as T,t as w,w as U}from"../chunks/index.98837b22.js";import{C as x}from"../chunks/CodeBlock.8d0c2e8a.js";import{H as j,E as $n}from"../chunks/getInferenceSnippets.06c2775f.js";import{H as _n,a as Yt}from"../chunks/HfOption.6641485e.js";function Jn(z){let m,C="The main advantage of mixed precision training is saving the activations in fp16.",y,f,$='Configure <code>fp16()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable mixed precision training with the fp16 data type.',_,r,h,c,J="fp16 isn‚Äôt memory-optimized because the gradients that are computed in fp16 are converted back to fp32 during the optimization step. You may end up using more GPU memory, especially for small batch sizes, because there are now two versions (fp16 and fp32) of the model on the GPU.",W;return r=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwZnAxNiUzRFRydWUuJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    fp16=<span class="hljs-literal">True</span>.
)`,wrap:!1}}),{c(){m=l("p"),m.textContent=C,y=s(),f=l("p"),f.innerHTML=$,_=s(),g(r.$$.fragment),h=s(),c=l("p"),c.textContent=J},l(d){m=o(d,"P",{"data-svelte-h":!0}),p(m)!=="svelte-1bscn8l"&&(m.textContent=C),y=i(d),f=o(d,"P",{"data-svelte-h":!0}),p(f)!=="svelte-1aogj5p"&&(f.innerHTML=$),_=i(d),M(r.$$.fragment,d),h=i(d),c=o(d,"P",{"data-svelte-h":!0}),p(c)!=="svelte-dmja6y"&&(c.textContent=J)},m(d,v){a(d,m,v),a(d,y,v),a(d,f,v),a(d,_,v),b(r,d,v),a(d,h,v),a(d,c,v),W=!0},p:kt,i(d){W||(T(r.$$.fragment,d),W=!0)},o(d){w(r.$$.fragment,d),W=!1},d(d){d&&(n(m),n(y),n(f),n(_),n(h),n(c)),U(r,d)}}}function vn(z){let m,C='<a href="https://cloud.google.com/blog/products/ai-machine-learning/bfloat16-the-secret-to-high-performance-on-cloud-tpus" rel="nofollow">bf16</a> trades off some precision for a much larger dynamic range, which is helpful for avoiding overflow and underflow errors. You can use bf16 without adding any loss scaling methods like you would with fp16. bf16 is supported by NVIDIAs Ampere architecture or newer.',y,f,$='Configure <code>bf16()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable mixed precision training with the bf16 data type.',_,r,h;return r=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUlMkMlMEEp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>,
)`,wrap:!1}}),{c(){m=l("p"),m.innerHTML=C,y=s(),f=l("p"),f.innerHTML=$,_=s(),g(r.$$.fragment)},l(c){m=o(c,"P",{"data-svelte-h":!0}),p(m)!=="svelte-ax7pvo"&&(m.innerHTML=C),y=i(c),f=o(c,"P",{"data-svelte-h":!0}),p(f)!=="svelte-1ot1565"&&(f.innerHTML=$),_=i(c),M(r.$$.fragment,c)},m(c,J){a(c,m,J),a(c,y,J),a(c,f,J),a(c,_,J),b(r,c,J),h=!0},p:kt,i(c){h||(T(r.$$.fragment,c),h=!0)},o(c){w(r.$$.fragment,c),h=!1},d(c){c&&(n(m),n(y),n(f),n(_)),U(r,c)}}}function Cn(z){let m,C='<a href="https://blogs.nvidia.com/blog/tensorfloat-32-precision-format/" rel="nofollow">tf32</a> is a mode on NVIDIA Ampere GPUs that convert the convolution and matrix multiplication inputs to tf32. All other storage and operations are kept in fp32. This allows tf32 to maintain the same range as fp32, the same precision as fp16 and more precision than bf16. Combining tf32 with fp16 or bf16 mixed precision training can improve throughput by 16x.',y,f,$="tf32 is enabled by default on NVIDIA Ampere GPUs, but you can also add the code below to your fp32 training or inference code to explicitly enable it.",_,r,h,c,J='Configure <a href="https://huggingface.co/docs/transformers/main_classes/trainer#transformers.TrainingArguments.tf32" rel="nofollow">tf32()</a> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable mixed precision training with tf32 mode.',W,d,v;return r=new x({props:{code:"aW1wb3J0JTIwdG9yY2glMEF0b3JjaC5iYWNrZW5kcy5jdWRhLm1hdG11bC5hbGxvd190ZjMyJTIwJTNEJTIwVHJ1ZSUwQXRvcmNoLmJhY2tlbmRzLmN1ZG5uLmFsbG93X3RmMzIlMjAlM0QlMjBUcnVl",highlighted:`<span class="hljs-keyword">import</span> torch
torch.backends.cuda.matmul.allow_tf32 = <span class="hljs-literal">True</span>
torch.backends.cudnn.allow_tf32 = <span class="hljs-literal">True</span>`,wrap:!1}}),d=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUuJTBBJTIwJTIwJTIwJTIwdGYzMiUzRFRydWUlMkMlMEEp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>.
    tf32=<span class="hljs-literal">True</span>,
)`,wrap:!1}}),{c(){m=l("p"),m.innerHTML=C,y=s(),f=l("p"),f.textContent=$,_=s(),g(r.$$.fragment),h=s(),c=l("p"),c.innerHTML=J,W=s(),g(d.$$.fragment)},l(u){m=o(u,"P",{"data-svelte-h":!0}),p(m)!=="svelte-hpv4q0"&&(m.innerHTML=C),y=i(u),f=o(u,"P",{"data-svelte-h":!0}),p(f)!=="svelte-lpbuco"&&(f.textContent=$),_=i(u),M(r.$$.fragment,u),h=i(u),c=o(u,"P",{"data-svelte-h":!0}),p(c)!=="svelte-1ku2i94"&&(c.innerHTML=J),W=i(u),M(d.$$.fragment,u)},m(u,R){a(u,m,R),a(u,y,R),a(u,f,R),a(u,_,R),b(r,u,R),a(u,h,R),a(u,c,R),a(u,W,R),b(d,u,R),v=!0},p:kt,i(u){v||(T(r.$$.fragment,u),T(d.$$.fragment,u),v=!0)},o(u){w(r.$$.fragment,u),w(d.$$.fragment,u),v=!1},d(u){u&&(n(m),n(y),n(f),n(_),n(h),n(c),n(W)),U(r,u),U(d,u)}}}function Wn(z){let m,C,y,f,$,_;return m=new Yt({props:{id:"mixed-precision",option:"fp16",$$slots:{default:[Jn]},$$scope:{ctx:z}}}),y=new Yt({props:{id:"mixed-precision",option:"bf16",$$slots:{default:[vn]},$$scope:{ctx:z}}}),$=new Yt({props:{id:"mixed-precision",option:"tf32",$$slots:{default:[Cn]},$$scope:{ctx:z}}}),{c(){g(m.$$.fragment),C=s(),g(y.$$.fragment),f=s(),g($.$$.fragment)},l(r){M(m.$$.fragment,r),C=i(r),M(y.$$.fragment,r),f=i(r),M($.$$.fragment,r)},m(r,h){b(m,r,h),a(r,C,h),b(y,r,h),a(r,f,h),b($,r,h),_=!0},p(r,h){const c={};h&2&&(c.$$scope={dirty:h,ctx:r}),m.$set(c);const J={};h&2&&(J.$$scope={dirty:h,ctx:r}),y.$set(J);const W={};h&2&&(W.$$scope={dirty:h,ctx:r}),$.$set(W)},i(r){_||(T(m.$$.fragment,r),T(y.$$.fragment,r),T($.$$.fragment,r),_=!0)},o(r){w(m.$$.fragment,r),w(y.$$.fragment,r),w($.$$.fragment,r),_=!1},d(r){r&&(n(C),n(f)),U(m,r),U(y,r),U($,r)}}}function Rn(z){let m,C,y,f,$,_,r,h="GPUs are commonly used to train deep learning models due to their high memory bandwidth and parallel processing capabilities. Depending on your GPU and model size, it is possible to even train models with billions of parameters. The key is to find the right balance between GPU memory utilization (data throughput/training time) and training speed.",c,J,W="This guide will show you the features available in Transformers and PyTorch for efficiently training a model on GPUs. In many cases, you‚Äôll want to use a combination of these features to optimize training.",d,v,u="Refer to the table below to quickly help you identify the features relevant to your training scenario.",R,k,At="<thead><tr><th>Feature</th> <th>Training speed</th> <th>Memory usage</th></tr></thead> <tbody><tr><td>batch size</td> <td>yes</td> <td>yes</td></tr> <tr><td>gradient accumulation</td> <td>no</td> <td>yes</td></tr> <tr><td>gradient checkpointing</td> <td>no</td> <td>yes</td></tr> <tr><td>mixed precision</td> <td>yes</td> <td>depends</td></tr> <tr><td>optimizers</td> <td>yes</td> <td>yes</td></tr> <tr><td>data preloading</td> <td>yes</td> <td>no</td></tr> <tr><td>torch_empty_cache_steps</td> <td>no</td> <td>yes</td></tr> <tr><td>torch.compile</td> <td>yes</td> <td>no</td></tr> <tr><td>scaled dot production attention (SDPA)</td> <td>yes</td> <td>yes</td></tr></tbody>",Ye,A,ke,B,Bt='<a href="./trainer">Trainer</a> supports many useful training features that can be configured through <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a>. This section highlights some of the more important features for optimizing training.',Ae,H,Be,G,Ht="Batch size is one of the most important hyperparameters for efficient GPU training because it affects memory usage and training speed. Larger batch sizes lead to faster training because it takes advantage of a GPUs parallel processing power. It is recommended to use batch sizes that are powers of 2, such as 8, 64, 128, 256, 512, etc. The batch size depends on your GPU and the models data type.",He,Z,Gt='Configure <code>per_device_train_batch_size()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a>.',Ge,I,Ze,X,Zt='Refer to the NVIDIA <a href="https://docs.nvidia.com/deeplearning/performance/dl-performance-fully-connected/index.html#input-features" rel="nofollow">Performance</a> guide to learn more about how input features and output neuron counts and batch size affect performance. These are involved in the General Matrix Multiplications (GEMMs) performed by the GPU. Larger parameters are better for parallelization and efficiency.',Ie,P,It='The <a href="https://docs.nvidia.com/deeplearning/performance/dl-performance-matrix-multiplication/index.html#requirements-tc" rel="nofollow">Tensor Core Requirements</a> section is also useful for selecting a batch size that maximizes the speed of tensor multiplication based on the data type and GPU. For example, multiples of 8 are recommended for fp16, unless it‚Äôs an A100 GPU, in which case use multiples of 64.',Xe,Q,Xt='Finally, consider <a href="https://docs.nvidia.com/deeplearning/performance/dl-performance-matrix-multiplication/index.html#dim-quantization" rel="nofollow">Dimension Quantization Effects</a> for smaller parameters. Tile quantization results when matrix dimensions aren‚Äôt divisible by a GPUs thread block tile size, causing the GPU to underutilize its resources. Selecting the correct batch size multiplier, such that the matrix is divisible by the tile size, can significantly speed up training.',Pe,F,Qe,L,Pt="Gradient accumulation overcomes memory constraints - useful for fitting a very large model that otherwise wouldn‚Äôt fit on a single GPU - by accumulating gradients over multiple mini-batches before updating the parameters. This reduces memory by storing fewer gradients and enables training with a larger <em>effective batch size</em> because usually, the parameters are updated from a single batch of data. Training can slow down though due to the additional forward and backward passes introduced by gradient accumulation.",Fe,N,Qt='Configure <code>per_device_train_batch_size()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable gradient accumulation.',Le,V,Ne,S,Ft="Try to avoid too many gradient accumulation steps because it can really slow down training. Consider the example below, where the maximum batch size that‚Äôll fit on your GPU is 4. You should keep your batch size at 4 to better utilize the GPU.",Ve,E,Lt="<thead><tr><th>batch size</th> <th>gradient accumulation steps</th> <th>effective batch size</th> <th></th></tr></thead> <tbody><tr><td>1</td> <td>64</td> <td>64</td> <td>üëé</td></tr> <tr><td>4</td> <td>16</td> <td>64</td> <td>üëç</td></tr></tbody>",Se,D,Ee,q,Nt="Gradient checkpointing reduces memory usage by only storing some of the intermediate activations during the backward pass and recomputing the remaining activations. This avoids storing <em>all</em> of the intermediate activations from the forward pass, which can require a lot of memory overhead. However, it comes at the cost of slower training speed (~20%).",De,K,Vt='Configure <code>gradient_checkpointing()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable gradient checkpointing.',qe,O,Ke,ee,Oe,te,St="Mixed precision accelerates training speed by performing some calculations in half-precision (fp16) and some in full-precision (fp32). The half-precision calculations boosts training speed because it‚Äôs not as computationally expensive as performing the calculations in full-precision. Meanwhile, preserving some of the calculations in full-precision maintains accuracy.",et,ne,Et="There are several data types available for mixed precision training.",tt,Y,nt,ae,at,se,Dt='Transformers implements the <a href="https://pytorch.org/docs/stable/generated/torch.optim.AdamW.html" rel="nofollow">AdamW (adamw_torch)</a> optimizer from PyTorch by default. But because it stores a weighted average of past gradients, it requires additional memory proportional to the number of model parameters to store the past gradients. This can be an issue when training very large models, and in such cases, you should consider choosing a different optimizer. For example, if you have <a href="https://nvidia.github.io/apex/index.html" rel="nofollow">Apex</a> installed on either <a href="https://github.com/NVIDIA/apex" rel="nofollow">NVIDIA</a> or <a href="https://github.com/ROCm/apex" rel="nofollow">AMD</a>, then using the <code>adamw_apex_fused</code> optimizer provides the fastest training for all AdamW optimizers.',st,ie,qt='Configure <code>optim()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to choose an optimizer.',it,re,rt,le,Kt='There are many optimizers to choose from (refer to <a href="https://github.com/huggingface/transformers/blob/34f4080ff59b1668d919a1ba9f8bc4a3a2a3f478/src/transformers/training_args.py#L145" rel="nofollow">OptimizerNames</a> for a full supported list) depending on your training scenario. For example, Adafactor can significantly reduce memory requirements by storing a weighted average of a row or column instead of each element in the matrix at the cost of slower convergence. Another example is using a <a href="https://huggingface.co/docs/bitsandbytes" rel="nofollow">8-bit AdamW optimizer</a> from bitsandbytes to quantize optimizer states. The optimizer state is stored in a lower precision and dequantized before being used in the optimizer step.',lt,oe,Ot='Refer to the <a href="./optimizers">optimizer</a> guide for to learn about more specialized optimizers.',ot,pe,pt,me,en="Data preloading loads and prepares batches of data in advance on the CPU to ensure the GPU is continuously working, reducing GPU idling and increasing utilization. There are two ways to preload data to ensure the GPU is always working.",mt,ce,tn="<li>Allocate pinned memory on the CPU to store the data and transfer it directly to the GPU.</li> <li>Increase the number of CPU threads or workers to preload the data faster.</li>",ct,de,nn='Configure <code>dataloader_pin_memory()</code> and <code>dataloader_num_workers()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to allocate pinned memory and increase the number of workers.',dt,fe,ft,ue,ut,he,an="PyTorch provides several features for reducing memory requirements and increasing training speed. These features can often be enabled in Transformers by only adding a few lines of code.",ht,ye,yt,ge,sn='The <a href="https://pytorch.org/docs/stable/generated/torch.cuda.empty_cache.html#torch.cuda.empty_cache" rel="nofollow">torch.cuda.empty_cache</a> function releases unused cached memory, which can help avoid out-of-memory (OOM) errors at the cost of ~10% slower training.',gt,Me,rn='Use <a href="https://huggingface.co/docs/transformers/main_classes/trainer#transformers.TrainingArguments.torch_empty_cache_steps" rel="nofollow">torch_empty_cache_steps()</a> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable it after a certain number of training steps.',Mt,be,bt,Te,Tt,we,ln='<a href="https://pytorch.org/tutorials/intermediate/torch_compile_tutorial.html" rel="nofollow">torch.compile</a> compiles PyTorch code into optimized kernels that significantly speed up training. This feature relies on TorchDynamo to capture PyTorch graphs with the Frame Evaluation API. The graph can be further compiled into optimized kernels for different backends.',wt,Ue,on='Configure <code>torch_compile()</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/trainer#transformers.TrainingArguments">TrainingArguments</a> to enable it, and configure <a href="https://huggingface.co/docs/transformers/main_classes/trainer#transformers.TrainingArguments.torch_compile_backend" rel="nofollow">torch_compile_backend()</a> to select a backend to use.',Ut,$e,$t,_e,pn="Refer to the table below to help you choose the right backend for your training scenario.",_t,Je,mn='<thead><tr><th>backend</th> <th>description</th> <th>goal</th></tr></thead> <tbody><tr><td>eager</td> <td>uses PyTorch to run extracted GraphModule</td> <td>debugging</td></tr> <tr><td>aot_eager</td> <td>uses PyTorch eager mode for AOTAutograd‚Äôs extracted forward and backward graphs</td> <td>debugging</td></tr> <tr><td>inductor</td> <td>uses TorchInductor with AOTAutograd and CUDA Graphs by leveraging Triton kernels</td> <td>training and inference</td></tr> <tr><td>nvfuser</td> <td>uses nvFuser with TorchScript</td> <td>training and inference</td></tr> <tr><td>aot_nvfuser</td> <td>uses nvFuser with AOTAutograd</td> <td>training and inference</td></tr> <tr><td>aot_cudagraphs</td> <td>uses CUDA Graphs with AOTAutograd</td> <td>training and inference</td></tr> <tr><td>ofi</td> <td>uses TorchScripts <a href="https://pytorch.org/docs/stable/generated/torch.jit.optimize_for_inference.html#torch-jit-optimize-for-inference" rel="nofollow">optimize_for_inference</a></td> <td>inference</td></tr> <tr><td>fx2trt</td> <td>uses <a href="https://pytorch.org/TensorRT/tutorials/getting_started_with_fx_path.html" rel="nofollow">Torch-TensorRT</a></td> <td>inference</td></tr> <tr><td>onnxrt</td> <td>uses <a href="https://onnxruntime.ai/" rel="nofollow">ONNX-RT</a> for CPU and GPU inference</td> <td>inference</td></tr> <tr><td>ipex</td> <td>uses <a href="https://github.com/intel/intel-extension-for-pytorch" rel="nofollow">IPEX</a> for CPU inference</td> <td>inference</td></tr></tbody>',Jt,ve,vt,Ce,cn='<a href="https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html" rel="nofollow">torch.nn.functional.scaled_dot_product_attention</a> (SDPA) is a native PyTorch implementation of the scaled dot product attention mechanism. SDPA is more efficient and optimized than the original attention mechanism in transformer models. It supports three types of scaled dot product attention.',Ct,We,dn='<li><a href="https://github.com/Dao-AILab/flash-attention" rel="nofollow">FlashAttention2</a> is automatically enabled for models with the fp16 or bf16 torch type. Make sure to cast your model to the appropriate type first.</li> <li><a href="https://github.com/facebookresearch/xformers" rel="nofollow">xFormers</a> or Memory-Efficient Attention supports models with the fp32 torch type.</li> <li>C++ implementation of scaled dot product attention.</li>',Wt,Re,fn='SDPA is enabled by default for PyTorch 2.1.1+, but it can be explicitly enabled by setting <code>attn_implementation=&quot;sdpa&quot;</code> in <a href="/docs/transformers/v4.56.2/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a>.',Rt,je,jt,xe,xt,ze,zt;return $=new j({props:{title:"GPU",local:"gpu",headingTag:"h1"}}),A=new j({props:{title:"Trainer",local:"trainer",headingTag:"h2"}}),H=new j({props:{title:"Batch size",local:"batch-size",headingTag:"h3"}}),I=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDI1NiUyQyUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfZXZhbF9iYXRjaF9zaXplJTNEMjU2JTJDJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">256</span>,
    per_device_eval_batch_size=<span class="hljs-number">256</span>,
)`,wrap:!1}}),F=new j({props:{title:"Gradient accumulation",local:"gradient-accumulation",headingTag:"h3"}}),V=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBJTIzJTIwZWZmZWN0aXZlJTIwYmF0Y2glMjBzaXplJTIwb2YlMjA2NCUwQWFyZ3MlMjAlM0QlMjBUcmFpbmluZ0FyZ3VtZW50cyglMEElMjAlMjAlMjAlMjBwZXJfZGV2aWNlX3RyYWluX2JhdGNoX3NpemUlM0Q0JTJDJTBBJTIwJTIwJTIwJTIwZ3JhZGllbnRfYWNjdW11bGF0aW9uX3N0ZXBzJTNEMTYlMkMlMEEp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

<span class="hljs-comment"># effective batch size of 64</span>
args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
)`,wrap:!1}}),D=new j({props:{title:"Gradient checkpointing",local:"gradient-checkpointing",headingTag:"h3"}}),O=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
)`,wrap:!1}}),ee=new j({props:{title:"Mixed precision",local:"mixed-precision",headingTag:"h3"}}),Y=new _n({props:{id:"mixed-precision",options:["fp16","bf16","tf32"],$$slots:{default:[Wn]},$$scope:{ctx:z}}}),ae=new j({props:{title:"Optimizers",local:"optimizers",headingTag:"h3"}}),re=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBvcHRpbSUzRCUyMmFkYW13X2JuYl84Yml0JTIyJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>,
    optim=<span class="hljs-string">&quot;adamw_bnb_8bit&quot;</span>
)`,wrap:!1}}),pe=new j({props:{title:"Data preloading",local:"data-preloading",headingTag:"h3"}}),fe=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBvcHRpbSUzRCUyMmFkYW13X2JuYl84Yml0JTIyJTJDJTBBJTIwJTIwJTIwJTIwZGF0YWxvYWRlcl9waW5fbWVtb3J5JTNEVHJ1ZSUyQyUwQSUyMCUyMCUyMCUyMGRhdGFsb2FkZXJfbnVtX3dvcmtlcnMlM0Q0JTJDJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>,
    optim=<span class="hljs-string">&quot;adamw_bnb_8bit&quot;</span>,
    dataloader_pin_memory=<span class="hljs-literal">True</span>,
    dataloader_num_workers=<span class="hljs-number">4</span>,
)`,wrap:!1}}),ue=new j({props:{title:"PyTorch",local:"pytorch",headingTag:"h2"}}),ye=new j({props:{title:"torch.empty_cache_steps",local:"torchemptycachesteps",headingTag:"h3"}}),be=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBvcHRpbSUzRCUyMmFkYW13X2JuYl84Yml0JTIyJTJDJTBBJTIwJTIwJTIwJTIwZGF0YWxvYWRlcl9waW5fbWVtb3J5JTNEVHJ1ZSUyQyUwQSUyMCUyMCUyMCUyMGRhdGFsb2FkZXJfbnVtX3dvcmtlcnMlM0Q0JTJDJTBBJTIwJTIwJTIwJTIwdG9yY2hfZW1wdHlfY2FjaGVfc3RlcHMlM0Q0JTJDJTBBKQ==",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>,
    optim=<span class="hljs-string">&quot;adamw_bnb_8bit&quot;</span>,
    dataloader_pin_memory=<span class="hljs-literal">True</span>,
    dataloader_num_workers=<span class="hljs-number">4</span>,
    torch_empty_cache_steps=<span class="hljs-number">4</span>,
)`,wrap:!1}}),Te=new j({props:{title:"torch.compile",local:"torchcompile",headingTag:"h3"}}),$e=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMFRyYWluaW5nQXJndW1lbnRzJTBBJTBBYXJncyUyMCUzRCUyMFRyYWluaW5nQXJndW1lbnRzKCUwQSUyMCUyMCUyMCUyMHBlcl9kZXZpY2VfdHJhaW5fYmF0Y2hfc2l6ZSUzRDQlMkMlMEElMjAlMjAlMjAlMjBncmFkaWVudF9hY2N1bXVsYXRpb25fc3RlcHMlM0QxNiUyQyUwQSUyMCUyMCUyMCUyMGdyYWRpZW50X2NoZWNrcG9pbnRpbmclM0RUcnVlJTJDJTBBJTIwJTIwJTIwJTIwYmYxNiUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjBvcHRpbSUzRCUyMmFkYW13X2JuYl84Yml0JTIyJTJDJTBBJTIwJTIwJTIwJTIwZGF0YWxvYWRlcl9waW5fbWVtb3J5JTNEVHJ1ZSUyQyUwQSUyMCUyMCUyMCUyMGRhdGFsb2FkZXJfbnVtX3dvcmtlcnMlM0Q0JTJDJTBBJTIwJTIwJTIwJTIwdG9yY2hfZW1wdHlfY2FjaGVfc3RlcHMlM0Q0JTJDJTBBJTIwJTIwJTIwJTIwdG9yY2hfY29tcGlsZSUzRFRydWUlMkMlMEElMjAlMjAlMjAlMjB0b3JjaF9jb21waWxlX2JhY2tlbmQlM0QlMjJpbmR1Y3RvciUyMiUwQSk=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

args = TrainingArguments(
    per_device_train_batch_size=<span class="hljs-number">4</span>,
    gradient_accumulation_steps=<span class="hljs-number">16</span>,
    gradient_checkpointing=<span class="hljs-literal">True</span>,
    bf16=<span class="hljs-literal">True</span>,
    optim=<span class="hljs-string">&quot;adamw_bnb_8bit&quot;</span>,
    dataloader_pin_memory=<span class="hljs-literal">True</span>,
    dataloader_num_workers=<span class="hljs-number">4</span>,
    torch_empty_cache_steps=<span class="hljs-number">4</span>,
    torch_compile=<span class="hljs-literal">True</span>,
    torch_compile_backend=<span class="hljs-string">&quot;inductor&quot;</span>
)`,wrap:!1}}),ve=new j({props:{title:"Scaled dot production attention",local:"scaled-dot-production-attention",headingTag:"h3"}}),je=new x({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTBBJTBBbW9kZWwlMjAlM0QlMjBBdXRvTW9kZWxGb3JDYXVzYWxMTS5mcm9tX3ByZXRyYWluZWQoJTIybWV0YS1sbGFtYSUyRkxsYW1hLTMuMS04QiUyMiUyQyUyMGRldmljZV9tYXAlM0QlMjJhdXRvJTIyJTJDJTIwYXR0bl9pbXBsZW1lbnRhdGlvbiUzRCUyMnNkcGElMjIp",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM

model = AutoModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;meta-llama/Llama-3.1-8B&quot;</span>, device_map=<span class="hljs-string">&quot;auto&quot;</span>, attn_implementation=<span class="hljs-string">&quot;sdpa&quot;</span>)`,wrap:!1}}),xe=new $n({props:{source:"https://github.com/huggingface/transformers/blob/main/docs/source/en/perf_train_gpu_one.md"}}),{c(){m=l("meta"),C=s(),y=l("p"),f=s(),g($.$$.fragment),_=s(),r=l("p"),r.textContent=h,c=s(),J=l("p"),J.textContent=W,d=s(),v=l("p"),v.textContent=u,R=s(),k=l("table"),k.innerHTML=At,Ye=s(),g(A.$$.fragment),ke=s(),B=l("p"),B.innerHTML=Bt,Ae=s(),g(H.$$.fragment),Be=s(),G=l("p"),G.textContent=Ht,He=s(),Z=l("p"),Z.innerHTML=Gt,Ge=s(),g(I.$$.fragment),Ze=s(),X=l("p"),X.innerHTML=Zt,Ie=s(),P=l("p"),P.innerHTML=It,Xe=s(),Q=l("p"),Q.innerHTML=Xt,Pe=s(),g(F.$$.fragment),Qe=s(),L=l("p"),L.innerHTML=Pt,Fe=s(),N=l("p"),N.innerHTML=Qt,Le=s(),g(V.$$.fragment),Ne=s(),S=l("p"),S.textContent=Ft,Ve=s(),E=l("table"),E.innerHTML=Lt,Se=s(),g(D.$$.fragment),Ee=s(),q=l("p"),q.innerHTML=Nt,De=s(),K=l("p"),K.innerHTML=Vt,qe=s(),g(O.$$.fragment),Ke=s(),g(ee.$$.fragment),Oe=s(),te=l("p"),te.textContent=St,et=s(),ne=l("p"),ne.textContent=Et,tt=s(),g(Y.$$.fragment),nt=s(),g(ae.$$.fragment),at=s(),se=l("p"),se.innerHTML=Dt,st=s(),ie=l("p"),ie.innerHTML=qt,it=s(),g(re.$$.fragment),rt=s(),le=l("p"),le.innerHTML=Kt,lt=s(),oe=l("p"),oe.innerHTML=Ot,ot=s(),g(pe.$$.fragment),pt=s(),me=l("p"),me.textContent=en,mt=s(),ce=l("ol"),ce.innerHTML=tn,ct=s(),de=l("p"),de.innerHTML=nn,dt=s(),g(fe.$$.fragment),ft=s(),g(ue.$$.fragment),ut=s(),he=l("p"),he.textContent=an,ht=s(),g(ye.$$.fragment),yt=s(),ge=l("p"),ge.innerHTML=sn,gt=s(),Me=l("p"),Me.innerHTML=rn,Mt=s(),g(be.$$.fragment),bt=s(),g(Te.$$.fragment),Tt=s(),we=l("p"),we.innerHTML=ln,wt=s(),Ue=l("p"),Ue.innerHTML=on,Ut=s(),g($e.$$.fragment),$t=s(),_e=l("p"),_e.textContent=pn,_t=s(),Je=l("table"),Je.innerHTML=mn,Jt=s(),g(ve.$$.fragment),vt=s(),Ce=l("p"),Ce.innerHTML=cn,Ct=s(),We=l("ul"),We.innerHTML=dn,Wt=s(),Re=l("p"),Re.innerHTML=fn,Rt=s(),g(je.$$.fragment),jt=s(),g(xe.$$.fragment),xt=s(),ze=l("p"),this.h()},l(e){const t=wn("svelte-u9bgzb",document.head);m=o(t,"META",{name:!0,content:!0}),t.forEach(n),C=i(e),y=o(e,"P",{}),hn(y).forEach(n),f=i(e),M($.$$.fragment,e),_=i(e),r=o(e,"P",{"data-svelte-h":!0}),p(r)!=="svelte-3v6hvz"&&(r.textContent=h),c=i(e),J=o(e,"P",{"data-svelte-h":!0}),p(J)!=="svelte-ryqnw1"&&(J.textContent=W),d=i(e),v=o(e,"P",{"data-svelte-h":!0}),p(v)!=="svelte-n9nqqn"&&(v.textContent=u),R=i(e),k=o(e,"TABLE",{"data-svelte-h":!0}),p(k)!=="svelte-y7552e"&&(k.innerHTML=At),Ye=i(e),M(A.$$.fragment,e),ke=i(e),B=o(e,"P",{"data-svelte-h":!0}),p(B)!=="svelte-xl3niy"&&(B.innerHTML=Bt),Ae=i(e),M(H.$$.fragment,e),Be=i(e),G=o(e,"P",{"data-svelte-h":!0}),p(G)!=="svelte-wr8hhu"&&(G.textContent=Ht),He=i(e),Z=o(e,"P",{"data-svelte-h":!0}),p(Z)!=="svelte-cv85dz"&&(Z.innerHTML=Gt),Ge=i(e),M(I.$$.fragment,e),Ze=i(e),X=o(e,"P",{"data-svelte-h":!0}),p(X)!=="svelte-1is384h"&&(X.innerHTML=Zt),Ie=i(e),P=o(e,"P",{"data-svelte-h":!0}),p(P)!=="svelte-hcpy7s"&&(P.innerHTML=It),Xe=i(e),Q=o(e,"P",{"data-svelte-h":!0}),p(Q)!=="svelte-1ftr8dz"&&(Q.innerHTML=Xt),Pe=i(e),M(F.$$.fragment,e),Qe=i(e),L=o(e,"P",{"data-svelte-h":!0}),p(L)!=="svelte-1g17env"&&(L.innerHTML=Pt),Fe=i(e),N=o(e,"P",{"data-svelte-h":!0}),p(N)!=="svelte-1is4z9m"&&(N.innerHTML=Qt),Le=i(e),M(V.$$.fragment,e),Ne=i(e),S=o(e,"P",{"data-svelte-h":!0}),p(S)!=="svelte-k7npc4"&&(S.textContent=Ft),Ve=i(e),E=o(e,"TABLE",{"data-svelte-h":!0}),p(E)!=="svelte-bg5pgv"&&(E.innerHTML=Lt),Se=i(e),M(D.$$.fragment,e),Ee=i(e),q=o(e,"P",{"data-svelte-h":!0}),p(q)!=="svelte-18nswaa"&&(q.innerHTML=Nt),De=i(e),K=o(e,"P",{"data-svelte-h":!0}),p(K)!=="svelte-6axn76"&&(K.innerHTML=Vt),qe=i(e),M(O.$$.fragment,e),Ke=i(e),M(ee.$$.fragment,e),Oe=i(e),te=o(e,"P",{"data-svelte-h":!0}),p(te)!=="svelte-45ttfx"&&(te.textContent=St),et=i(e),ne=o(e,"P",{"data-svelte-h":!0}),p(ne)!=="svelte-1qka8ue"&&(ne.textContent=Et),tt=i(e),M(Y.$$.fragment,e),nt=i(e),M(ae.$$.fragment,e),at=i(e),se=o(e,"P",{"data-svelte-h":!0}),p(se)!=="svelte-16728rv"&&(se.innerHTML=Dt),st=i(e),ie=o(e,"P",{"data-svelte-h":!0}),p(ie)!=="svelte-64y2qm"&&(ie.innerHTML=qt),it=i(e),M(re.$$.fragment,e),rt=i(e),le=o(e,"P",{"data-svelte-h":!0}),p(le)!=="svelte-17at21e"&&(le.innerHTML=Kt),lt=i(e),oe=o(e,"P",{"data-svelte-h":!0}),p(oe)!=="svelte-50osy"&&(oe.innerHTML=Ot),ot=i(e),M(pe.$$.fragment,e),pt=i(e),me=o(e,"P",{"data-svelte-h":!0}),p(me)!=="svelte-pe87pi"&&(me.textContent=en),mt=i(e),ce=o(e,"OL",{"data-svelte-h":!0}),p(ce)!=="svelte-1rkn94"&&(ce.innerHTML=tn),ct=i(e),de=o(e,"P",{"data-svelte-h":!0}),p(de)!=="svelte-1ez4sxd"&&(de.innerHTML=nn),dt=i(e),M(fe.$$.fragment,e),ft=i(e),M(ue.$$.fragment,e),ut=i(e),he=o(e,"P",{"data-svelte-h":!0}),p(he)!=="svelte-13irw7t"&&(he.textContent=an),ht=i(e),M(ye.$$.fragment,e),yt=i(e),ge=o(e,"P",{"data-svelte-h":!0}),p(ge)!=="svelte-1nu9tjf"&&(ge.innerHTML=sn),gt=i(e),Me=o(e,"P",{"data-svelte-h":!0}),p(Me)!=="svelte-14rw37b"&&(Me.innerHTML=rn),Mt=i(e),M(be.$$.fragment,e),bt=i(e),M(Te.$$.fragment,e),Tt=i(e),we=o(e,"P",{"data-svelte-h":!0}),p(we)!=="svelte-bl5sl8"&&(we.innerHTML=ln),wt=i(e),Ue=o(e,"P",{"data-svelte-h":!0}),p(Ue)!=="svelte-2jutrd"&&(Ue.innerHTML=on),Ut=i(e),M($e.$$.fragment,e),$t=i(e),_e=o(e,"P",{"data-svelte-h":!0}),p(_e)!=="svelte-1ci7jd6"&&(_e.textContent=pn),_t=i(e),Je=o(e,"TABLE",{"data-svelte-h":!0}),p(Je)!=="svelte-3qwh9d"&&(Je.innerHTML=mn),Jt=i(e),M(ve.$$.fragment,e),vt=i(e),Ce=o(e,"P",{"data-svelte-h":!0}),p(Ce)!=="svelte-sep83h"&&(Ce.innerHTML=cn),Ct=i(e),We=o(e,"UL",{"data-svelte-h":!0}),p(We)!=="svelte-jhgahq"&&(We.innerHTML=dn),Wt=i(e),Re=o(e,"P",{"data-svelte-h":!0}),p(Re)!=="svelte-1djtcpt"&&(Re.innerHTML=fn),Rt=i(e),M(je.$$.fragment,e),jt=i(e),M(xe.$$.fragment,e),xt=i(e),ze=o(e,"P",{}),hn(ze).forEach(n),this.h()},h(){yn(m,"name","hf:doc:metadata"),yn(m,"content",jn)},m(e,t){Un(document.head,m),a(e,C,t),a(e,y,t),a(e,f,t),b($,e,t),a(e,_,t),a(e,r,t),a(e,c,t),a(e,J,t),a(e,d,t),a(e,v,t),a(e,R,t),a(e,k,t),a(e,Ye,t),b(A,e,t),a(e,ke,t),a(e,B,t),a(e,Ae,t),b(H,e,t),a(e,Be,t),a(e,G,t),a(e,He,t),a(e,Z,t),a(e,Ge,t),b(I,e,t),a(e,Ze,t),a(e,X,t),a(e,Ie,t),a(e,P,t),a(e,Xe,t),a(e,Q,t),a(e,Pe,t),b(F,e,t),a(e,Qe,t),a(e,L,t),a(e,Fe,t),a(e,N,t),a(e,Le,t),b(V,e,t),a(e,Ne,t),a(e,S,t),a(e,Ve,t),a(e,E,t),a(e,Se,t),b(D,e,t),a(e,Ee,t),a(e,q,t),a(e,De,t),a(e,K,t),a(e,qe,t),b(O,e,t),a(e,Ke,t),b(ee,e,t),a(e,Oe,t),a(e,te,t),a(e,et,t),a(e,ne,t),a(e,tt,t),b(Y,e,t),a(e,nt,t),b(ae,e,t),a(e,at,t),a(e,se,t),a(e,st,t),a(e,ie,t),a(e,it,t),b(re,e,t),a(e,rt,t),a(e,le,t),a(e,lt,t),a(e,oe,t),a(e,ot,t),b(pe,e,t),a(e,pt,t),a(e,me,t),a(e,mt,t),a(e,ce,t),a(e,ct,t),a(e,de,t),a(e,dt,t),b(fe,e,t),a(e,ft,t),b(ue,e,t),a(e,ut,t),a(e,he,t),a(e,ht,t),b(ye,e,t),a(e,yt,t),a(e,ge,t),a(e,gt,t),a(e,Me,t),a(e,Mt,t),b(be,e,t),a(e,bt,t),b(Te,e,t),a(e,Tt,t),a(e,we,t),a(e,wt,t),a(e,Ue,t),a(e,Ut,t),b($e,e,t),a(e,$t,t),a(e,_e,t),a(e,_t,t),a(e,Je,t),a(e,Jt,t),b(ve,e,t),a(e,vt,t),a(e,Ce,t),a(e,Ct,t),a(e,We,t),a(e,Wt,t),a(e,Re,t),a(e,Rt,t),b(je,e,t),a(e,jt,t),b(xe,e,t),a(e,xt,t),a(e,ze,t),zt=!0},p(e,[t]){const un={};t&2&&(un.$$scope={dirty:t,ctx:e}),Y.$set(un)},i(e){zt||(T($.$$.fragment,e),T(A.$$.fragment,e),T(H.$$.fragment,e),T(I.$$.fragment,e),T(F.$$.fragment,e),T(V.$$.fragment,e),T(D.$$.fragment,e),T(O.$$.fragment,e),T(ee.$$.fragment,e),T(Y.$$.fragment,e),T(ae.$$.fragment,e),T(re.$$.fragment,e),T(pe.$$.fragment,e),T(fe.$$.fragment,e),T(ue.$$.fragment,e),T(ye.$$.fragment,e),T(be.$$.fragment,e),T(Te.$$.fragment,e),T($e.$$.fragment,e),T(ve.$$.fragment,e),T(je.$$.fragment,e),T(xe.$$.fragment,e),zt=!0)},o(e){w($.$$.fragment,e),w(A.$$.fragment,e),w(H.$$.fragment,e),w(I.$$.fragment,e),w(F.$$.fragment,e),w(V.$$.fragment,e),w(D.$$.fragment,e),w(O.$$.fragment,e),w(ee.$$.fragment,e),w(Y.$$.fragment,e),w(ae.$$.fragment,e),w(re.$$.fragment,e),w(pe.$$.fragment,e),w(fe.$$.fragment,e),w(ue.$$.fragment,e),w(ye.$$.fragment,e),w(be.$$.fragment,e),w(Te.$$.fragment,e),w($e.$$.fragment,e),w(ve.$$.fragment,e),w(je.$$.fragment,e),w(xe.$$.fragment,e),zt=!1},d(e){e&&(n(C),n(y),n(f),n(_),n(r),n(c),n(J),n(d),n(v),n(R),n(k),n(Ye),n(ke),n(B),n(Ae),n(Be),n(G),n(He),n(Z),n(Ge),n(Ze),n(X),n(Ie),n(P),n(Xe),n(Q),n(Pe),n(Qe),n(L),n(Fe),n(N),n(Le),n(Ne),n(S),n(Ve),n(E),n(Se),n(Ee),n(q),n(De),n(K),n(qe),n(Ke),n(Oe),n(te),n(et),n(ne),n(tt),n(nt),n(at),n(se),n(st),n(ie),n(it),n(rt),n(le),n(lt),n(oe),n(ot),n(pt),n(me),n(mt),n(ce),n(ct),n(de),n(dt),n(ft),n(ut),n(he),n(ht),n(yt),n(ge),n(gt),n(Me),n(Mt),n(bt),n(Tt),n(we),n(wt),n(Ue),n(Ut),n($t),n(_e),n(_t),n(Je),n(Jt),n(vt),n(Ce),n(Ct),n(We),n(Wt),n(Re),n(Rt),n(jt),n(xt),n(ze)),n(m),U($,e),U(A,e),U(H,e),U(I,e),U(F,e),U(V,e),U(D,e),U(O,e),U(ee,e),U(Y,e),U(ae,e),U(re,e),U(pe,e),U(fe,e),U(ue,e),U(ye,e),U(be,e),U(Te,e),U($e,e),U(ve,e),U(je,e),U(xe,e)}}}const jn='{"title":"GPU","local":"gpu","sections":[{"title":"Trainer","local":"trainer","sections":[{"title":"Batch size","local":"batch-size","sections":[],"depth":3},{"title":"Gradient accumulation","local":"gradient-accumulation","sections":[],"depth":3},{"title":"Gradient checkpointing","local":"gradient-checkpointing","sections":[],"depth":3},{"title":"Mixed precision","local":"mixed-precision","sections":[],"depth":3},{"title":"Optimizers","local":"optimizers","sections":[],"depth":3},{"title":"Data preloading","local":"data-preloading","sections":[],"depth":3}],"depth":2},{"title":"PyTorch","local":"pytorch","sections":[{"title":"torch.empty_cache_steps","local":"torchemptycachesteps","sections":[],"depth":3},{"title":"torch.compile","local":"torchcompile","sections":[],"depth":3},{"title":"Scaled dot production attention","local":"scaled-dot-production-attention","sections":[],"depth":3}],"depth":2}],"depth":1}';function xn(z){return Mn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Hn extends bn{constructor(m){super(),Tn(this,m,xn,Rn,gn,{})}}export{Hn as component};
