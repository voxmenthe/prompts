import{s as Ve,o as Fe,n as Ye}from"../chunks/scheduler.18a86fab.js";import{S as Ne,i as Se,g as i,s as l,r as w,A as Qe,h as s,f as o,c as n,j as ee,x as d,u as T,k as Ce,y as r,a,v as $,d as _,t as k,w as L}from"../chunks/index.98837b22.js";import{T as De}from"../chunks/Tip.77304350.js";import{C as He}from"../chunks/CodeBlock.8d0c2e8a.js";import{H as Me,E as Oe}from"../chunks/getInferenceSnippets.06c2775f.js";function Ke(te){let m,C=`The <code>Llama3</code> models were trained using <code>bfloat16</code>, but the original inference uses <code>float16</code>. The checkpoints uploaded on the Hub use <code>dtype = &#39;float16&#39;</code>, which will be
used by the <code>AutoModel</code> API to cast the checkpoints from <code>torch.float32</code> to <code>torch.float16</code>.`,b,f,M="The <code>dtype</code> of the online weights is mostly irrelevant unless you are using <code>dtype=&quot;auto&quot;</code> when initializing a model using <code>model = AutoModelForCausalLM.from_pretrained(&quot;path&quot;, dtype = &quot;auto&quot;)</code>. The reason is that the model will first be downloaded ( using the <code>dtype</code> of the checkpoints online), then it will be casted to the default <code>dtype</code> of <code>torch</code> (becomes <code>torch.float32</code>), and finally, if there is a <code>dtype</code> or <code>torch_dtype</code> provided in the config, it will be used.",H,g,y="Training the model in <code>float16</code> is not recommended and is known to produce <code>nan</code>; as such, the model should be trained in <code>bfloat16</code>.";return{c(){m=i("p"),m.innerHTML=C,b=l(),f=i("p"),f.innerHTML=M,H=l(),g=i("p"),g.innerHTML=y},l(p){m=s(p,"P",{"data-svelte-h":!0}),d(m)!=="svelte-c2o8l6"&&(m.innerHTML=C),b=n(p),f=s(p,"P",{"data-svelte-h":!0}),d(f)!=="svelte-eziksx"&&(f.innerHTML=M),H=n(p),g=s(p,"P",{"data-svelte-h":!0}),d(g)!=="svelte-wna3bo"&&(g.innerHTML=y)},m(p,u){a(p,m,u),a(p,b,u),a(p,f,u),a(p,H,u),a(p,g,u)},p:Ye,d(p){p&&(o(m),o(b),o(f),o(H),o(g))}}}function et(te){let m,C,b,f,M,H="<em>This model was released on 2024-04-18 and added to Hugging Face Transformers on 2024-04-24.</em>",g,y,p,u,Ue='<img alt="PyTorch" src="https://img.shields.io/badge/PyTorch-DE3412?style=flat&amp;logo=pytorch&amp;logoColor=white"/> <img alt="Tensor parallelism" src="https://img.shields.io/badge/Tensor%20parallelism-06b6d4?style=flat&amp;logoColor=white"/>',oe,U,ae,J,le,j,Je='The <a href="https://huggingface.co/papers/2407.21783" rel="nofollow">Llama3</a> model was proposed in <a href="https://ai.meta.com/blog/meta-llama-3/" rel="nofollow">Introducing Meta Llama 3: The most capable openly available LLM to date</a> by the meta AI team.',ne,q,je="The abstract from the blogpost is the following:",ie,W,qe="<em>Today, we‚Äôre excited to share the first two models of the next generation of Llama, Meta Llama 3, available for broad use. This release features pretrained and instruction-fine-tuned language models with 8B and 70B parameters that can support a broad range of use cases. This next generation of Llama demonstrates state-of-the-art performance on a wide range of industry benchmarks and offers new capabilities, including improved reasoning. We believe these are the best open source models of their class, period. In support of our longstanding open approach, we‚Äôre putting Llama 3 in the hands of the community. We want to kickstart the next wave of innovation in AI across the stack‚Äîfrom applications to developer tools to evals to inference optimizations and more. We can‚Äôt wait to see what you build and look forward to your feedback.</em>",se,G,We=`Checkout all Llama3 model checkpoints <a href="https://huggingface.co/models?search=llama3" rel="nofollow">here</a>.
The original code of the authors can be found <a href="https://github.com/meta-llama/llama3" rel="nofollow">here</a>.`,re,R,de,x,pe,Z,Ge="Tips:",ce,c,P,Re='<p>Weights for the Llama3 models can be obtained by filling out <a href="https://ai.meta.com/resources/models-and-libraries/llama-downloads/" rel="nofollow">this form</a></p>',ye,V,Ze="<p>The architecture is exactly the same as Llama2.</p>",ve,F,Ee='<p>The tokenizer is a BPE model based on <a href="https://github.com/openai/tiktoken" rel="nofollow">tiktoken</a> (vs the one based on sentencepiece implementation for Llama2). The main difference that it ignores BPE merge rules when an input token is part of the vocab. This means that if no merge exist to produce <code>&quot;hugging&quot;</code>, instead of having the smallest units, like <code>[&quot;hug&quot;,&quot;ging&quot;] form 2 tokens, if </code>‚Äúhugging‚Äù` is part of the vocab, it will be automatically returned as a token.</p>',we,Y,ze="<p>The original model uses <code>pad_id = -1</code> which means that there is no padding token. We can‚Äôt have the same logic, make sure to add a padding token using <code>tokenizer.add_special_tokens({&quot;pad_token&quot;:&quot;&lt;pad&gt;&quot;})</code> and resize the token embedding accordingly. You should also set the <code>model.config.pad_token_id</code>. The <code>embed_tokens</code> layer of the model is initialized with <code>self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.config.padding_idx)</code>, which makes sure that encoding the padding token will output zeros, so passing it when initializing is recommended.</p>",Te,E,N,Ae='The original checkpoint can be converted using the <a href="https://github.com/huggingface/transformers/blob/main/src/transformers/models/llama/convert_llama_weights_to_hf.py" rel="nofollow">conversion script</a>. The script can be called with the following (example) command:',$e,z,_e,v,S,Xe="After conversion, the model and tokenizer can be loaded via:",ke,A,Le,Q,Ie=`Note that executing the script requires enough CPU RAM to host the whole model in float16 precision (even if the biggest versions
come in several checkpoints they each contain a part of each weight of the model, so we need to load them all in RAM). For the 75B model, it‚Äôs thus 145GB of RAM needed.`,xe,D,Be="<p>When using Flash Attention 2 via <code>attn_implementation=&quot;flash_attention_2&quot;</code>, don‚Äôt pass <code>dtype</code> to the <code>from_pretrained</code> class method and use Automatic Mixed-Precision training. When using <code>Trainer</code>, it is simply specifying either <code>fp16</code> or <code>bf16</code> to <code>True</code>. Otherwise, make sure you are using <code>torch.autocast</code>. This is required because the Flash Attention only support <code>fp16</code> and <code>bf16</code> data type.</p>",me,X,he,I,Pe='A ton of cool resources are already available on the documentation page of <a href="./llama2">Llama2</a>, inviting contributors to add new resources curated for Llama3 here! ü§ó',ue,B,fe,K,ge;return y=new Me({props:{title:"Llama3",local:"llama3",headingTag:"h1"}}),U=new He({props:{code:"aW1wb3J0JTIwdHJhbnNmb3JtZXJzJTBBaW1wb3J0JTIwdG9yY2glMEElMEFtb2RlbF9pZCUyMCUzRCUyMCUyMm1ldGEtbGxhbWElMkZNZXRhLUxsYW1hLTMtOEIlMjIlMEElMEFwaXBlbGluZSUyMCUzRCUyMHRyYW5zZm9ybWVycy5waXBlbGluZSglMjJ0ZXh0LWdlbmVyYXRpb24lMjIlMkMlMjBtb2RlbCUzRG1vZGVsX2lkJTJDJTIwbW9kZWxfa3dhcmdzJTNEJTdCJTIyZHR5cGUlMjIlM0ElMjB0b3JjaC5iZmxvYXQxNiU3RCUyQyUyMGRldmljZV9tYXAlM0QlMjJhdXRvJTIyKSUwQXBpcGVsaW5lKCUyMkhleSUyMGhvdyUyMGFyZSUyMHlvdSUyMGRvaW5nJTIwdG9kYXklM0YlMjIp",highlighted:`<span class="hljs-keyword">import</span> transformers
<span class="hljs-keyword">import</span> torch

<span class="hljs-title">model_id</span> = <span class="hljs-string">&quot;meta-llama/Meta-Llama-3-8B&quot;</span>

<span class="hljs-title">pipeline</span> = transformers.pipeline(<span class="hljs-string">&quot;text-generation&quot;</span>, model=model_id, model_kwargs={<span class="hljs-string">&quot;dtype&quot;</span>: torch.bfloat16}, device_map=<span class="hljs-string">&quot;auto&quot;</span>)
<span class="hljs-title">pipeline</span>(<span class="hljs-string">&quot;Hey how are you doing today?&quot;</span>)`,wrap:!1}}),J=new Me({props:{title:"Overview",local:"overview",headingTag:"h2"}}),R=new Me({props:{title:"Usage tips",local:"usage-tips",headingTag:"h2"}}),x=new De({props:{warning:!0,$$slots:{default:[Ke]},$$scope:{ctx:te}}}),z=new He({props:{code:"cHl0aG9uJTIwc3JjJTJGdHJhbnNmb3JtZXJzJTJGbW9kZWxzJTJGbGxhbWElMkZjb252ZXJ0X2xsYW1hX3dlaWdodHNfdG9faGYucHklMjAlNUMlMEElMjAlMjAlMjAlMjAtLWlucHV0X2RpciUyMCUyRnBhdGglMkZ0byUyRmRvd25sb2FkZWQlMkZsbGFtYSUyRndlaWdodHMlMjAtLW1vZGVsX3NpemUlMjA3QiUyMC0tb3V0cHV0X2RpciUyMCUyRm91dHB1dCUyRnBhdGglMjAtLWxsYW1hX3ZlcnNpb24lMjAz",highlighted:`python src/transformers/models/llama/convert_llama_weights_to_hf.py \\
    --input_dir /path/to/downloaded/llama/weights --model_size 7B --output_dir /output/path --llama_version 3`,wrap:!1}}),A=new He({props:{code:"ZnJvbSUyMHRyYW5zZm9ybWVycyUyMGltcG9ydCUyMEF1dG9Nb2RlbEZvckNhdXNhbExNJTJDJTIwQXV0b1Rva2VuaXplciUwQSUwQXRva2VuaXplciUyMCUzRCUyMEF1dG9Ub2tlbml6ZXIuZnJvbV9wcmV0cmFpbmVkKCUyMiUyRm91dHB1dCUyRnBhdGglMjIpJTBBbW9kZWwlMjAlM0QlMjBBdXRvTW9kZWxGb3JDYXVzYWxMTS5mcm9tX3ByZXRyYWluZWQoJTIyJTJGb3V0cHV0JTJGcGF0aCUyMik=",highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer

tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)
model = AutoModelForCausalLM.from_pretrained(<span class="hljs-string">&quot;/output/path&quot;</span>)`,wrap:!1}}),X=new Me({props:{title:"Resources",local:"resources",headingTag:"h2"}}),B=new Oe({props:{source:"https://github.com/huggingface/transformers/blob/main/docs/source/en/model_doc/llama3.md"}}),{c(){m=i("meta"),C=l(),b=i("p"),f=l(),M=i("p"),M.innerHTML=H,g=l(),w(y.$$.fragment),p=l(),u=i("div"),u.innerHTML=Ue,oe=l(),w(U.$$.fragment),ae=l(),w(J.$$.fragment),le=l(),j=i("p"),j.innerHTML=Je,ne=l(),q=i("p"),q.textContent=je,ie=l(),W=i("p"),W.innerHTML=qe,se=l(),G=i("p"),G.innerHTML=We,re=l(),w(R.$$.fragment),de=l(),w(x.$$.fragment),pe=l(),Z=i("p"),Z.textContent=Ge,ce=l(),c=i("ul"),P=i("li"),P.innerHTML=Re,ye=l(),V=i("li"),V.innerHTML=Ze,ve=l(),F=i("li"),F.innerHTML=Ee,we=l(),Y=i("li"),Y.innerHTML=ze,Te=l(),E=i("li"),N=i("p"),N.innerHTML=Ae,$e=l(),w(z.$$.fragment),_e=l(),v=i("li"),S=i("p"),S.textContent=Xe,ke=l(),w(A.$$.fragment),Le=l(),Q=i("p"),Q.textContent=Ie,xe=l(),D=i("li"),D.innerHTML=Be,me=l(),w(X.$$.fragment),he=l(),I=i("p"),I.innerHTML=Pe,ue=l(),w(B.$$.fragment),fe=l(),K=i("p"),this.h()},l(e){const t=Qe("svelte-u9bgzb",document.head);m=s(t,"META",{name:!0,content:!0}),t.forEach(o),C=n(e),b=s(e,"P",{}),ee(b).forEach(o),f=n(e),M=s(e,"P",{"data-svelte-h":!0}),d(M)!=="svelte-t7mqa5"&&(M.innerHTML=H),g=n(e),T(y.$$.fragment,e),p=n(e),u=s(e,"DIV",{class:!0,"data-svelte-h":!0}),d(u)!=="svelte-3qtnnx"&&(u.innerHTML=Ue),oe=n(e),T(U.$$.fragment,e),ae=n(e),T(J.$$.fragment,e),le=n(e),j=s(e,"P",{"data-svelte-h":!0}),d(j)!=="svelte-1pygpma"&&(j.innerHTML=Je),ne=n(e),q=s(e,"P",{"data-svelte-h":!0}),d(q)!=="svelte-14ru3ry"&&(q.textContent=je),ie=n(e),W=s(e,"P",{"data-svelte-h":!0}),d(W)!=="svelte-ggt8ju"&&(W.innerHTML=qe),se=n(e),G=s(e,"P",{"data-svelte-h":!0}),d(G)!=="svelte-1xj5glz"&&(G.innerHTML=We),re=n(e),T(R.$$.fragment,e),de=n(e),T(x.$$.fragment,e),pe=n(e),Z=s(e,"P",{"data-svelte-h":!0}),d(Z)!=="svelte-axv494"&&(Z.textContent=Ge),ce=n(e),c=s(e,"UL",{});var h=ee(c);P=s(h,"LI",{"data-svelte-h":!0}),d(P)!=="svelte-152iser"&&(P.innerHTML=Re),ye=n(h),V=s(h,"LI",{"data-svelte-h":!0}),d(V)!=="svelte-1gaq40l"&&(V.innerHTML=Ze),ve=n(h),F=s(h,"LI",{"data-svelte-h":!0}),d(F)!=="svelte-2r23bq"&&(F.innerHTML=Ee),we=n(h),Y=s(h,"LI",{"data-svelte-h":!0}),d(Y)!=="svelte-1iokj9y"&&(Y.innerHTML=ze),Te=n(h),E=s(h,"LI",{});var be=ee(E);N=s(be,"P",{"data-svelte-h":!0}),d(N)!=="svelte-1vss5eo"&&(N.innerHTML=Ae),$e=n(be),T(z.$$.fragment,be),be.forEach(o),_e=n(h),v=s(h,"LI",{});var O=ee(v);S=s(O,"P",{"data-svelte-h":!0}),d(S)!=="svelte-b5pwv6"&&(S.textContent=Xe),ke=n(O),T(A.$$.fragment,O),Le=n(O),Q=s(O,"P",{"data-svelte-h":!0}),d(Q)!=="svelte-oga8ra"&&(Q.textContent=Ie),O.forEach(o),xe=n(h),D=s(h,"LI",{"data-svelte-h":!0}),d(D)!=="svelte-1ghagko"&&(D.innerHTML=Be),h.forEach(o),me=n(e),T(X.$$.fragment,e),he=n(e),I=s(e,"P",{"data-svelte-h":!0}),d(I)!=="svelte-f4fme6"&&(I.innerHTML=Pe),ue=n(e),T(B.$$.fragment,e),fe=n(e),K=s(e,"P",{}),ee(K).forEach(o),this.h()},h(){Ce(m,"name","hf:doc:metadata"),Ce(m,"content",tt),Ce(u,"class","flex flex-wrap space-x-1")},m(e,t){r(document.head,m),a(e,C,t),a(e,b,t),a(e,f,t),a(e,M,t),a(e,g,t),$(y,e,t),a(e,p,t),a(e,u,t),a(e,oe,t),$(U,e,t),a(e,ae,t),$(J,e,t),a(e,le,t),a(e,j,t),a(e,ne,t),a(e,q,t),a(e,ie,t),a(e,W,t),a(e,se,t),a(e,G,t),a(e,re,t),$(R,e,t),a(e,de,t),$(x,e,t),a(e,pe,t),a(e,Z,t),a(e,ce,t),a(e,c,t),r(c,P),r(c,ye),r(c,V),r(c,ve),r(c,F),r(c,we),r(c,Y),r(c,Te),r(c,E),r(E,N),r(E,$e),$(z,E,null),r(c,_e),r(c,v),r(v,S),r(v,ke),$(A,v,null),r(v,Le),r(v,Q),r(c,xe),r(c,D),a(e,me,t),$(X,e,t),a(e,he,t),a(e,I,t),a(e,ue,t),$(B,e,t),a(e,fe,t),a(e,K,t),ge=!0},p(e,[t]){const h={};t&2&&(h.$$scope={dirty:t,ctx:e}),x.$set(h)},i(e){ge||(_(y.$$.fragment,e),_(U.$$.fragment,e),_(J.$$.fragment,e),_(R.$$.fragment,e),_(x.$$.fragment,e),_(z.$$.fragment,e),_(A.$$.fragment,e),_(X.$$.fragment,e),_(B.$$.fragment,e),ge=!0)},o(e){k(y.$$.fragment,e),k(U.$$.fragment,e),k(J.$$.fragment,e),k(R.$$.fragment,e),k(x.$$.fragment,e),k(z.$$.fragment,e),k(A.$$.fragment,e),k(X.$$.fragment,e),k(B.$$.fragment,e),ge=!1},d(e){e&&(o(C),o(b),o(f),o(M),o(g),o(p),o(u),o(oe),o(ae),o(le),o(j),o(ne),o(q),o(ie),o(W),o(se),o(G),o(re),o(de),o(pe),o(Z),o(ce),o(c),o(me),o(he),o(I),o(ue),o(fe),o(K)),o(m),L(y,e),L(U,e),L(J,e),L(R,e),L(x,e),L(z),L(A),L(X,e),L(B,e)}}}const tt='{"title":"Llama3","local":"llama3","sections":[{"title":"Overview","local":"overview","sections":[],"depth":2},{"title":"Usage tips","local":"usage-tips","sections":[],"depth":2},{"title":"Resources","local":"resources","sections":[],"depth":2}],"depth":1}';function ot(te){return Fe(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class rt extends Ne{constructor(m){super(),Se(this,m,ot,et,Ve,{})}}export{rt as component};
