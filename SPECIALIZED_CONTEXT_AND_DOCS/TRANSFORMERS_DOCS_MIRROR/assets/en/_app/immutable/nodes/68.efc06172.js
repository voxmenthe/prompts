import{s as Ql,o as Ll,n as Hl}from"../chunks/scheduler.18a86fab.js";import{S as Al,i as Dl,g as r,s as n,r as d,A as Ml,h as a,f as s,c as o,j as h,u as l,x as u,k as _,y as t,a as g,v as m,d as c,t as f,w as p}from"../chunks/index.98837b22.js";import{T as Fl}from"../chunks/Tip.77304350.js";import{D as b}from"../chunks/Docstring.a1ef7999.js";import{H as x,E as Nl}from"../chunks/getInferenceSnippets.06c2775f.js";function El(lr){let q,Se='Learn how to quantize models in the <a href="../quantization">Quantization</a> guide.';return{c(){q=r("p"),q.innerHTML=Se},l(P){q=a(P,"P",{"data-svelte-h":!0}),u(q)!=="svelte-1pv1tva"&&(q.innerHTML=Se)},m(P,Hn){g(P,q,Hn)},p:Hl,d(P){P&&s(q)}}}function Il(lr){let q,Se,P,Hn,Re,mr,je,md="Quantization techniques reduce memory and computational costs by representing weights and activations with lower-precision data types like 8-bit integers (int8). This enables loading larger models you normally wouldn’t be able to fit into memory, and speeding up inference. Transformers supports the AWQ and GPTQ quantization algorithms and it supports 8-bit and 4-bit quantization with bitsandbytes.",cr,We,cd="Quantization techniques that aren’t supported in Transformers can be added with the <code>HfQuantizer</code> class.",fr,Y,pr,Ue,ur,Q,Ye,Ka,An,fd=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using <code>quanto</code>.`,Za,J,Je,es,Dn,pd="Safety checker that arguments are correct",gr,Xe,hr,L,Ke,ts,Mn,ud="This is a wrapper class about <code>aqlm</code> parameters.",ns,X,Ze,os,Fn,gd="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",_r,et,br,H,tt,rs,Nn,hd="This is a wrapper class about <code>vptq</code> parameters.",as,K,nt,ss,En,_d="Safety checker that arguments are correct",vr,ot,$r,A,rt,is,In,bd=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using <code>auto-awq</code> library awq quantization relying on auto_awq backend.`,ds,Z,at,ls,Vn,vd="Safety checker that arguments are correct",yr,st,xr,D,it,ms,Gn,$d=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using <code>eetq</code>.`,cs,ee,dt,fs,Bn,yd="Safety checker that arguments are correct",qr,lt,Cr,z,mt,ps,On,xd=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using <code>optimum</code> api for gptq quantization relying on auto_gptq backend.`,us,te,ct,gs,Sn,qd="Get compatible class with optimum gptq config dict",hs,ne,ft,_s,Rn,Cd="Safety checker that arguments are correct",bs,oe,pt,vs,jn,zd="Get compatible dict for optimum gptq config",zr,ut,wr,y,gt,$s,Wn,wd=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using <code>bitsandbytes</code>.`,ys,Un,Td="This replaces <code>load_in_8bit</code> or <code>load_in_4bit</code>therefore both options are mutually exclusive.",xs,Yn,kd=`Currently only supports <code>LLM.int8()</code>, <code>FP4</code>, and <code>NF4</code> quantization. If more methods are added to <code>bitsandbytes</code>,
then more arguments will be added to this class.`,qs,re,ht,Cs,Jn,Pd="Returns <code>True</code> if the model is quantizable, <code>False</code> otherwise.",zs,ae,_t,ws,Xn,Qd="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",Ts,se,bt,ks,Kn,Ld=`This method returns the quantization method used for the model. If the model is not quantizable, it returns
<code>None</code>.`,Ps,ie,vt,Qs,Zn,Hd=`Removes all attributes from config which correspond to the default config attributes for better readability and
serializes to a Python dictionary.`,Tr,$t,kr,v,yt,Ls,eo,Ad=`Abstract class of the HuggingFace quantizer. Supports for now quantizing HF transformers models for inference and/or quantization.
This class is used only for transformers.PreTrainedModel.from_pretrained and cannot be easily used outside the scope of that method
yet.`,Hs,to,Dd=`Attributes
quantization_config (<code>transformers.utils.quantization_config.QuantizationConfigMixin</code>):
The quantization config that defines the quantization parameters of your model that you want to quantize.
modules_to_not_convert (<code>list[str]</code>, <em>optional</em>):
The list of module names to not convert when quantizing the model.
required_packages (<code>list[str]</code>, <em>optional</em>):
The list of required pip packages to install prior to using the quantizer
requires_calibration (<code>bool</code>):
Whether the quantization method requires to calibrate the model before using it.
requires_parameters_quantization (<code>bool</code>):
Whether the quantization method requires to create a new Parameter. For example, for bitsandbytes, it is
required to create a new xxxParameter in order to properly quantize the model.`,As,de,xt,Ds,no,Md="adjust max_memory argument for infer_auto_device_map() if extra memory is needed for quantization",Ms,le,qt,Fs,oo,Fd=`Override this method if you want to adjust the <code>target_dtype</code> variable used in <code>from_pretrained</code>
to compute the device_map in case the device_map is a <code>str</code>. E.g. for bitsandbytes we force-set <code>target_dtype</code>
to <code>torch.int8</code> and for 4-bit we pass a custom enum <code>accelerate.CustomDtype.int4</code>.`,Ns,me,Ct,Es,ro,Nd=`checks if a loaded state_dict component is part of quantized param + some validation; only defined if
requires_parameters_quantization == True for quantization methods that require to create a new parameters
for quantization.`,Is,ce,zt,Vs,ao,Ed=`takes needed components from state_dict and creates quantized param; only applicable if
requires_parameters_quantization == True`,Gs,fe,wt,Bs,so,Id=`Potentially dequantize the model to retrieve the original model, with some loss in accuracy / performance.
Note not all quantization schemes support this.`,Os,pe,Tt,Ss,io,Vd=`The factor to be used in <code>caching_allocator_warmup</code> to get the number of bytes to pre-allocate to warm up accelerator.
A factor of 2 means we allocate all bytes in the empty model (since we allocate in fp16), a factor of 4 means
we allocate half the memory of the weights residing in the empty model, etc…`,Rs,ue,kt,js,lo,Gd=`returns dtypes for modules that are not quantized - used for the computation of the device_map in case
one passes a str as a device_map. The method will use the <code>modules_to_not_convert</code> that is modified
in <code>_process_model_before_weight_loading</code>.`,Ws,ge,Pt,Us,mo,Bd="Get state dict. Useful when we need to modify a bit the state dict due to quantization",Ys,he,Qt,Js,co,Od=`Post-process the model post weights loading.
Make sure to override the abstract method <code>_process_model_after_weight_loading</code>.`,Xs,_e,Lt,Ks,fo,Sd=`Setting model attributes and/or converting model before weights loading. At this point
the model should be initialized on the meta device so you can freely manipulate the skeleton
of the model in order to replace modules in-place. Make sure to override the abstract method <code>_process_model_before_weight_loading</code>.`,Zs,be,Ht,ei,po,Rd="Remove the quantization config from the model.",ti,ve,At,ni,uo,jd=`Override this method if you want to pass a override the existing device map with a new
one. E.g. for bitsandbytes, since <code>accelerate</code> is a hard requirement, if no device_map is
passed, the device_map is set to \`“auto”“`,oi,$e,Dt,ri,go,Wd=`Some quantization methods require to explicitly set the dtype of the model to a
target dtype. You need to override this method in case you want to make sure that behavior is
preserved`,ai,ye,Mt,si,ho,Ud="Override this method if you want to adjust the <code>update_expected_keys</code>.",ii,xe,Ft,di,_o,Yd="Override this method if you want to adjust the <code>missing_keys</code>.",li,qe,Nt,mi,bo,Jd=`Override this method if you want to adjust the <code>missing_keys</code> after loading the model params,
but before the model is post-processed.`,ci,Ce,Et,fi,vo,Xd="Override this method if you want to adjust the <code>param_name</code>.",pi,ze,It,ui,$o,Kd="Deprecared in favor of <code>update_dtype</code>!",gi,we,Vt,hi,yo,Zd="updates the tp plan for the scales",_i,Te,Gt,bi,xo,el="Override this method if you want to adjust the <code>unexpected_keys</code>.",vi,ke,Bt,$i,qo,tl=`This method is used to potentially check for potential conflicts with arguments that are
passed in <code>from_pretrained</code>. You need to define it for all future quantizers that are integrated with transformers.
If no explicit check are needed, simply return nothing.`,Pr,Ot,Qr,M,St,yi,Co,nl="HiggsConfig is a configuration class for quantization using the HIGGS method.",xi,Pe,Rt,qi,zo,ol="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",Lr,jt,Hr,w,Wt,Ci,wo,rl="This is wrapper around hqq’s BaseQuantizeConfig.",zi,Qe,Ut,wi,To,al="Override from_dict, used in AutoQuantizationConfig.from_dict in quantizers/auto.py",Ti,Le,Yt,ki,ko,sl="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",Pi,He,Jt,Qi,Po,il=`Removes all attributes from config which correspond to the default config attributes for better readability and
serializes to a Python dictionary.`,Ar,Xt,Dr,j,Kt,Li,Qo,dl=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using mxfp4 quantization.`,Mr,Zt,Fr,W,en,Hi,Lo,ll=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded using fbgemm fp8 quantization.`,Nr,tn,Er,T,nn,Ai,Ho,ml=`This is a wrapper class that handles compressed-tensors quantization config options.
It is a wrapper around <code>compressed_tensors.QuantizationConfig</code>`,Di,Ae,on,Mi,Ao,cl=`Instantiates a <a href="/docs/transformers/v4.56.2/en/main_classes/quantization#transformers.CompressedTensorsConfig">CompressedTensorsConfig</a> from a Python dictionary of parameters.
Optionally unwraps any args from the nested quantization_config`,Fi,G,rn,Ni,Do,fl="Quantization config to be added to config.json",Ei,Mo,pl=`Serializes this instance to a Python dictionary. Returns:
<code>dict[str, Any]</code>: Dictionary of all the attributes that make up this configuration instance.`,Ii,De,an,Vi,Fo,ul=`Removes all attributes from config which correspond to the default config attributes for better readability and
serializes to a Python dictionary.`,Ir,sn,Vr,k,dn,Gi,Me,ln,Bi,No,gl="Create configuration from a dictionary.",Oi,Fe,mn,Si,Eo,hl="Create the appropriate quantization method based on configuration.",Ri,Ne,cn,ji,Io,_l="Validate configuration and set defaults.",Wi,Ee,fn,Ui,Vo,bl="Convert configuration to a dictionary.",Gr,pn,Br,F,un,Yi,Go,vl="Configuration class for applying BitNet quantization.",Ji,Ie,gn,Xi,Bo,$l="Safety checker that arguments are correct",Or,hn,Sr,N,_n,Ki,Oo,yl="This is a wrapper class about <code>spqr</code> parameters. Refer to the original publication for more details.",Zi,Ve,bn,ed,So,xl="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",Rr,vn,jr,E,$n,td,Ro,ql="FineGrainedFP8Config is a configuration class for fine-grained FP8 quantization used mainly for deepseek models.",nd,Ge,yn,od,jo,Cl="Safety checker that arguments are correct",Wr,xn,Ur,qn,Cn,Yr,zn,Jr,I,wn,rd,Wo,zl="FPQuantConfig is a configuration class for quantization using the FPQuant method.",ad,Be,Tn,sd,Uo,wl="Safety checker that arguments are correct - also replaces some NoneType arguments with their default values.",Xr,kn,Kr,V,Pn,id,Yo,Tl=`This is a wrapper class about all possible attributes and features that you can play with a model that has been
loaded AutoRound quantization.`,dd,Oe,Qn,ld,Jo,kl="Safety checker that arguments are correct.",Zr,Ln,ea,dr,ta;return Re=new x({props:{title:"Quantization",local:"quantization",headingTag:"h1"}}),Y=new Fl({props:{$$slots:{default:[El]},$$scope:{ctx:lr}}}),Ue=new x({props:{title:"QuantoConfig",local:"transformers.QuantoConfig",headingTag:"h2"}}),Ye=new b({props:{name:"class transformers.QuantoConfig",anchor:"transformers.QuantoConfig",parameters:[{name:"weights",val:" = 'int8'"},{name:"activations",val:" = None"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.QuantoConfig.weights",description:`<strong>weights</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;int8&quot;</code>) &#x2014;
The target dtype for the weights after quantization. Supported values are (&#x201C;float8&#x201D;,&#x201C;int8&#x201D;,&#x201C;int4&#x201D;,&#x201C;int2&#x201D;)`,name:"weights"},{anchor:"transformers.QuantoConfig.activations",description:`<strong>activations</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The target dtype for the activations after quantization. Supported values are (None,&#x201C;int8&#x201D;,&#x201C;float8&#x201D;)`,name:"activations"},{anchor:"transformers.QuantoConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision (e.g. Whisper encoder, Llava encoder, Mixtral gate layers).`,name:"modules_to_not_convert"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1211"}}),Je=new b({props:{name:"post_init",anchor:"transformers.QuantoConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1239"}}),Xe=new x({props:{title:"AqlmConfig",local:"transformers.AqlmConfig",headingTag:"h2"}}),Ke=new b({props:{name:"class transformers.AqlmConfig",anchor:"transformers.AqlmConfig",parameters:[{name:"in_group_size",val:": int = 8"},{name:"out_group_size",val:": int = 1"},{name:"num_codebooks",val:": int = 1"},{name:"nbits_per_codebook",val:": int = 16"},{name:"linear_weights_not_to_quantize",val:": typing.Optional[list[str]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AqlmConfig.in_group_size",description:`<strong>in_group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 8) &#x2014;
The group size along the input dimension.`,name:"in_group_size"},{anchor:"transformers.AqlmConfig.out_group_size",description:`<strong>out_group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The group size along the output dimension. It&#x2019;s recommended to always use 1.`,name:"out_group_size"},{anchor:"transformers.AqlmConfig.num_codebooks",description:`<strong>num_codebooks</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Number of codebooks for the Additive Quantization procedure.`,name:"num_codebooks"},{anchor:"transformers.AqlmConfig.nbits_per_codebook",description:`<strong>nbits_per_codebook</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
Number of bits encoding a single codebook vector. Codebooks size is 2**nbits_per_codebook.`,name:"nbits_per_codebook"},{anchor:"transformers.AqlmConfig.linear_weights_not_to_quantize",description:`<strong>linear_weights_not_to_quantize</strong> (<code>Optional[list[str]]</code>, <em>optional</em>) &#x2014;
List of full paths of <code>nn.Linear</code> weight parameters that shall not be quantized.`,name:"linear_weights_not_to_quantize"},{anchor:"transformers.AqlmConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1055"}}),Ze=new b({props:{name:"post_init",anchor:"transformers.AqlmConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1092"}}),et=new x({props:{title:"VptqConfig",local:"transformers.VptqConfig",headingTag:"h2"}}),tt=new b({props:{name:"class transformers.VptqConfig",anchor:"transformers.VptqConfig",parameters:[{name:"enable_proxy_error",val:": bool = False"},{name:"config_for_layers",val:": dict = {}"},{name:"shared_layer_config",val:": dict = {}"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.VptqConfig.enable_proxy_error",description:"<strong>enable_proxy_error</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014; calculate proxy error for each layer",name:"enable_proxy_error"},{anchor:"transformers.VptqConfig.config_for_layers",description:"<strong>config_for_layers</strong> (<code>Dict</code>, <em>optional</em>, defaults to <code>{}</code>) &#x2014; quantization params for each layer",name:"config_for_layers"},{anchor:"transformers.VptqConfig.shared_layer_config",description:"<strong>shared_layer_config</strong> (<code>Dict</code>, <em>optional</em>, defaults to <code>{}</code>) &#x2014; shared quantization params among layers",name:"shared_layer_config"},{anchor:"transformers.VptqConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision (e.g. Whisper encoder, Llava encoder, Mixtral gate layers).`,name:"modules_to_not_convert"},{anchor:"transformers.VptqConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1170"}}),nt=new b({props:{name:"post_init",anchor:"transformers.VptqConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1200"}}),ot=new x({props:{title:"AwqConfig",local:"transformers.AwqConfig",headingTag:"h2"}}),rt=new b({props:{name:"class transformers.AwqConfig",anchor:"transformers.AwqConfig",parameters:[{name:"bits",val:": int = 4"},{name:"group_size",val:": int = 128"},{name:"zero_point",val:": bool = True"},{name:"version",val:": AWQLinearVersion = <AWQLinearVersion.GEMM: 'gemm'>"},{name:"backend",val:": AwqBackendPackingMethod = <AwqBackendPackingMethod.AUTOAWQ: 'autoawq'>"},{name:"do_fuse",val:": typing.Optional[bool] = None"},{name:"fuse_max_seq_len",val:": typing.Optional[int] = None"},{name:"modules_to_fuse",val:": typing.Optional[dict] = None"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"exllama_config",val:": typing.Optional[dict[str, int]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AwqConfig.bits",description:`<strong>bits</strong> (<code>int</code>, <em>optional</em>, defaults to 4) &#x2014;
The number of bits to quantize to.`,name:"bits"},{anchor:"transformers.AwqConfig.group_size",description:`<strong>group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
The group size to use for quantization. Recommended value is 128 and -1 uses per-column quantization.`,name:"group_size"},{anchor:"transformers.AwqConfig.zero_point",description:`<strong>zero_point</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to use zero point quantization.`,name:"zero_point"},{anchor:"transformers.AwqConfig.version",description:`<strong>version</strong> (<code>AWQLinearVersion</code>, <em>optional</em>, defaults to <code>AWQLinearVersion.GEMM</code>) &#x2014;
The version of the quantization algorithm to use. GEMM is better for big batch_size (e.g. &gt;= 8) otherwise,
GEMV is better (e.g. &lt; 8 ). GEMM models are compatible with Exllama kernels.`,name:"version"},{anchor:"transformers.AwqConfig.backend",description:`<strong>backend</strong> (<code>AwqBackendPackingMethod</code>, <em>optional</em>, defaults to <code>AwqBackendPackingMethod.AUTOAWQ</code>) &#x2014;
The quantization backend. Some models might be quantized using <code>llm-awq</code> backend. This is useful for users
that quantize their own models using <code>llm-awq</code> library.`,name:"backend"},{anchor:"transformers.AwqConfig.do_fuse",description:`<strong>do_fuse</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fuse attention and mlp layers together for faster inference`,name:"do_fuse"},{anchor:"transformers.AwqConfig.fuse_max_seq_len",description:`<strong>fuse_max_seq_len</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The Maximum sequence length to generate when using fusing.`,name:"fuse_max_seq_len"},{anchor:"transformers.AwqConfig.modules_to_fuse",description:`<strong>modules_to_fuse</strong> (<code>dict</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
Overwrite the natively supported fusing scheme with the one specified by the users.`,name:"modules_to_fuse"},{anchor:"transformers.AwqConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision (e.g. Whisper encoder, Llava encoder, Mixtral gate layers).
Note you cannot quantize directly with transformers, please refer to <code>AutoAWQ</code> documentation for quantizing HF models.`,name:"modules_to_not_convert"},{anchor:"transformers.AwqConfig.exllama_config",description:`<strong>exllama_config</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
You can specify the version of the exllama kernel through the <code>version</code> key, the maximum sequence
length through the <code>max_input_len</code> key, and the maximum batch size through the <code>max_batch_size</code> key.
Defaults to <code>{&quot;version&quot;: 2, &quot;max_input_len&quot;: 2048, &quot;max_batch_size&quot;: 8}</code> if unset.`,name:"exllama_config"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L878"}}),at=new b({props:{name:"post_init",anchor:"transformers.AwqConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L946"}}),st=new x({props:{title:"EetqConfig",local:"transformers.EetqConfig",headingTag:"h2"}}),it=new b({props:{name:"class transformers.EetqConfig",anchor:"transformers.EetqConfig",parameters:[{name:"weights",val:": str = 'int8'"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.EetqConfig.weights",description:`<strong>weights</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;int8&quot;</code>) &#x2014;
The target dtype for the weights. Supported value is only &#x201C;int8&#x201D;`,name:"weights"},{anchor:"transformers.EetqConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision.`,name:"modules_to_not_convert"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1252"}}),dt=new b({props:{name:"post_init",anchor:"transformers.EetqConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1276"}}),lt=new x({props:{title:"GPTQConfig",local:"transformers.GPTQConfig",headingTag:"h2"}}),mt=new b({props:{name:"class transformers.GPTQConfig",anchor:"transformers.GPTQConfig",parameters:[{name:"bits",val:": int"},{name:"tokenizer",val:": typing.Any = None"},{name:"dataset",val:": typing.Union[str, list[str], NoneType] = None"},{name:"group_size",val:": int = 128"},{name:"damp_percent",val:": float = 0.1"},{name:"desc_act",val:": bool = False"},{name:"sym",val:": bool = True"},{name:"true_sequential",val:": bool = True"},{name:"checkpoint_format",val:": str = 'gptq'"},{name:"meta",val:": typing.Optional[dict[str, typing.Any]] = None"},{name:"backend",val:": typing.Optional[str] = None"},{name:"use_cuda_fp16",val:": bool = False"},{name:"model_seqlen",val:": typing.Optional[int] = None"},{name:"block_name_to_quantize",val:": typing.Optional[str] = None"},{name:"module_name_preceding_first_block",val:": typing.Optional[list[str]] = None"},{name:"batch_size",val:": int = 1"},{name:"pad_token_id",val:": typing.Optional[int] = None"},{name:"use_exllama",val:": typing.Optional[bool] = None"},{name:"max_input_length",val:": typing.Optional[int] = None"},{name:"exllama_config",val:": typing.Optional[dict[str, typing.Any]] = None"},{name:"cache_block_outputs",val:": bool = True"},{name:"modules_in_block_to_quantize",val:": typing.Optional[list[list[str]]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.GPTQConfig.bits",description:`<strong>bits</strong> (<code>int</code>) &#x2014;
The number of bits to quantize to, supported numbers are (2, 3, 4, 8).`,name:"bits"},{anchor:"transformers.GPTQConfig.tokenizer",description:`<strong>tokenizer</strong> (<code>str</code> or <code>PreTrainedTokenizerBase</code>, <em>optional</em>) &#x2014;
The tokenizer used to process the dataset. You can pass either:<ul>
<li>A custom tokenizer object.</li>
<li>A string, the <em>model id</em> of a predefined tokenizer hosted inside a model repo on huggingface.co.</li>
<li>A path to a <em>directory</em> containing vocabulary files required by the tokenizer, for instance saved
using the <a href="/docs/transformers/v4.56.2/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.save_pretrained">save_pretrained()</a> method, e.g., <code>./my_model_directory/</code>.</li>
</ul>`,name:"tokenizer"},{anchor:"transformers.GPTQConfig.dataset",description:`<strong>dataset</strong> (<code>Union[list[str]]</code>, <em>optional</em>) &#x2014;
The dataset used for quantization. You can provide your own dataset in a list of string or just use the
original datasets used in GPTQ paper [&#x2018;wikitext2&#x2019;,&#x2018;c4&#x2019;,&#x2018;c4-new&#x2019;]`,name:"dataset"},{anchor:"transformers.GPTQConfig.group_size",description:`<strong>group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014;
The group size to use for quantization. Recommended value is 128 and -1 uses per-column quantization.`,name:"group_size"},{anchor:"transformers.GPTQConfig.damp_percent",description:`<strong>damp_percent</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The percent of the average Hessian diagonal to use for dampening. Recommended value is 0.1.`,name:"damp_percent"},{anchor:"transformers.GPTQConfig.desc_act",description:`<strong>desc_act</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to quantize columns in order of decreasing activation size. Setting it to False can significantly
speed up inference but the perplexity may become slightly worse. Also known as act-order.`,name:"desc_act"},{anchor:"transformers.GPTQConfig.sym",description:`<strong>sym</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to use symmetric quantization.`,name:"sym"},{anchor:"transformers.GPTQConfig.true_sequential",description:`<strong>true_sequential</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to perform sequential quantization even within a single Transformer block. Instead of quantizing
the entire block at once, we perform layer-wise quantization. As a result, each layer undergoes
quantization using inputs that have passed through the previously quantized layers.`,name:"true_sequential"},{anchor:"transformers.GPTQConfig.checkpoint_format",description:`<strong>checkpoint_format</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;gptq&quot;</code>) &#x2014;
GPTQ weight format. <code>gptq</code>(v1) is supported by both gptqmodel and auto-gptq. <code>gptq_v2</code> is gptqmodel only.`,name:"checkpoint_format"},{anchor:"transformers.GPTQConfig.meta",description:`<strong>meta</strong> (<code>dict[str, any]</code>, <em>optional</em>) &#x2014;
Properties, such as tooling:version, that do not directly contributes to quantization or quant inference are stored in meta.
i.e. <code>meta.quantizer</code>: [&#x201C;optimum:<em>version</em>&#x201D;, &#x201C;gptqmodel:<em>version</em>&#x201D;]`,name:"meta"},{anchor:"transformers.GPTQConfig.backend",description:`<strong>backend</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Controls which gptq kernel to be used. Valid values for gptqmodel are <code>auto</code>, <code>auto_trainable</code> and more. For auto-gptq, only
valid value is None and <code>auto_trainable</code>. Ref gptqmodel backends: <a href="https://github.com/ModelCloud/GPTQModel/blob/main/gptqmodel/utils/backend.py" rel="nofollow">https://github.com/ModelCloud/GPTQModel/blob/main/gptqmodel/utils/backend.py</a>`,name:"backend"},{anchor:"transformers.GPTQConfig.use_cuda_fp16",description:`<strong>use_cuda_fp16</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use optimized cuda kernel for fp16 model. Need to have model in fp16. Auto-gptq only.`,name:"use_cuda_fp16"},{anchor:"transformers.GPTQConfig.model_seqlen",description:`<strong>model_seqlen</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The maximum sequence length that the model can take.`,name:"model_seqlen"},{anchor:"transformers.GPTQConfig.block_name_to_quantize",description:`<strong>block_name_to_quantize</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The transformers block name to quantize. If None, we will infer the block name using common patterns (e.g. model.layers)`,name:"block_name_to_quantize"},{anchor:"transformers.GPTQConfig.module_name_preceding_first_block",description:`<strong>module_name_preceding_first_block</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The layers that are preceding the first Transformer block.`,name:"module_name_preceding_first_block"},{anchor:"transformers.GPTQConfig.batch_size",description:`<strong>batch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
The batch size used when processing the dataset`,name:"batch_size"},{anchor:"transformers.GPTQConfig.pad_token_id",description:`<strong>pad_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The pad token id. Needed to prepare the dataset when <code>batch_size</code> &gt; 1.`,name:"pad_token_id"},{anchor:"transformers.GPTQConfig.use_exllama",description:`<strong>use_exllama</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to use exllama backend. Defaults to <code>True</code> if unset. Only works with <code>bits</code> = 4.`,name:"use_exllama"},{anchor:"transformers.GPTQConfig.max_input_length",description:`<strong>max_input_length</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The maximum input length. This is needed to initialize a buffer that depends on the maximum expected input
length. It is specific to the exllama backend with act-order.`,name:"max_input_length"},{anchor:"transformers.GPTQConfig.exllama_config",description:`<strong>exllama_config</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
The exllama config. You can specify the version of the exllama kernel through the <code>version</code> key. Defaults
to <code>{&quot;version&quot;: 1}</code> if unset.`,name:"exllama_config"},{anchor:"transformers.GPTQConfig.cache_block_outputs",description:`<strong>cache_block_outputs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to cache block outputs to reuse as inputs for the succeeding block.`,name:"cache_block_outputs"},{anchor:"transformers.GPTQConfig.modules_in_block_to_quantize",description:`<strong>modules_in_block_to_quantize</strong> (<code>list[list[str]]</code>, <em>optional</em>) &#x2014;
List of list of module names to quantize in the specified block. This argument is useful to exclude certain linear modules from being quantized.
The block to quantize can be specified by setting <code>block_name_to_quantize</code>. We will quantize each list sequentially. If not set, we will quantize all linear layers.
Example: <code>modules_in_block_to_quantize =[[&quot;self_attn.k_proj&quot;, &quot;self_attn.v_proj&quot;, &quot;self_attn.q_proj&quot;], [&quot;self_attn.o_proj&quot;]]</code>.
In this example, we will first quantize the q,k,v layers simultaneously since they are independent.
Then, we will quantize <code>self_attn.o_proj</code> layer with the q,k,v layers quantized. This way, we will get
better results since it reflects the real input <code>self_attn.o_proj</code> will get when the model is quantized.`,name:"modules_in_block_to_quantize"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L641"}}),ct=new b({props:{name:"from_dict_optimum",anchor:"transformers.GPTQConfig.from_dict_optimum",parameters:[{name:"config_dict",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L862"}}),ft=new b({props:{name:"post_init",anchor:"transformers.GPTQConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L773"}}),pt=new b({props:{name:"to_dict_optimum",anchor:"transformers.GPTQConfig.to_dict_optimum",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L853"}}),ut=new x({props:{title:"BitsAndBytesConfig",local:"transformers.BitsAndBytesConfig",headingTag:"h2"}}),gt=new b({props:{name:"class transformers.BitsAndBytesConfig",anchor:"transformers.BitsAndBytesConfig",parameters:[{name:"load_in_8bit",val:" = False"},{name:"load_in_4bit",val:" = False"},{name:"llm_int8_threshold",val:" = 6.0"},{name:"llm_int8_skip_modules",val:" = None"},{name:"llm_int8_enable_fp32_cpu_offload",val:" = False"},{name:"llm_int8_has_fp16_weight",val:" = False"},{name:"bnb_4bit_compute_dtype",val:" = None"},{name:"bnb_4bit_quant_type",val:" = 'fp4'"},{name:"bnb_4bit_use_double_quant",val:" = False"},{name:"bnb_4bit_quant_storage",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.BitsAndBytesConfig.load_in_8bit",description:`<strong>load_in_8bit</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
This flag is used to enable 8-bit quantization with LLM.int8().`,name:"load_in_8bit"},{anchor:"transformers.BitsAndBytesConfig.load_in_4bit",description:`<strong>load_in_4bit</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
This flag is used to enable 4-bit quantization by replacing the Linear layers with FP4/NF4 layers from
<code>bitsandbytes</code>.`,name:"load_in_4bit"},{anchor:"transformers.BitsAndBytesConfig.llm_int8_threshold",description:`<strong>llm_int8_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 6.0) &#x2014;
This corresponds to the outlier threshold for outlier detection as described in <code>LLM.int8() : 8-bit Matrix Multiplication for Transformers at Scale</code> paper: <a href="https://huggingface.co/papers/2208.07339" rel="nofollow">https://huggingface.co/papers/2208.07339</a> Any hidden states value
that is above this threshold will be considered an outlier and the operation on those values will be done
in fp16. Values are usually normally distributed, that is, most values are in the range [-3.5, 3.5], but
there are some exceptional systematic outliers that are very differently distributed for large models.
These outliers are often in the interval [-60, -6] or [6, 60]. Int8 quantization works well for values of
magnitude ~5, but beyond that, there is a significant performance penalty. A good default threshold is 6,
but a lower threshold might be needed for more unstable models (small models, fine-tuning).`,name:"llm_int8_threshold"},{anchor:"transformers.BitsAndBytesConfig.llm_int8_skip_modules",description:`<strong>llm_int8_skip_modules</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
An explicit list of the modules that we do not want to convert in 8-bit. This is useful for models such as
Jukebox that has several heads in different places and not necessarily at the last position. For example
for <code>CausalLM</code> models, the last <code>lm_head</code> is kept in its original <code>dtype</code>.`,name:"llm_int8_skip_modules"},{anchor:"transformers.BitsAndBytesConfig.llm_int8_enable_fp32_cpu_offload",description:`<strong>llm_int8_enable_fp32_cpu_offload</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
This flag is used for advanced use cases and users that are aware of this feature. If you want to split
your model in different parts and run some parts in int8 on GPU and some parts in fp32 on CPU, you can use
this flag. This is useful for offloading large models such as <code>google/flan-t5-xxl</code>. Note that the int8
operations will not be run on CPU.`,name:"llm_int8_enable_fp32_cpu_offload"},{anchor:"transformers.BitsAndBytesConfig.llm_int8_has_fp16_weight",description:`<strong>llm_int8_has_fp16_weight</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
This flag runs LLM.int8() with 16-bit main weights. This is useful for fine-tuning as the weights do not
have to be converted back and forth for the backward pass.`,name:"llm_int8_has_fp16_weight"},{anchor:"transformers.BitsAndBytesConfig.bnb_4bit_compute_dtype",description:`<strong>bnb_4bit_compute_dtype</strong> (<code>torch.dtype</code> or str, <em>optional</em>, defaults to <code>torch.float32</code>) &#x2014;
This sets the computational type which might be different than the input type. For example, inputs might be
fp32, but computation can be set to bf16 for speedups.`,name:"bnb_4bit_compute_dtype"},{anchor:"transformers.BitsAndBytesConfig.bnb_4bit_quant_type",description:`<strong>bnb_4bit_quant_type</strong> (<code>str</code>,  <em>optional</em>, defaults to <code>&quot;fp4&quot;</code>) &#x2014;
This sets the quantization data type in the bnb.nn.Linear4Bit layers. Options are FP4 and NF4 data types
which are specified by <code>fp4</code> or <code>nf4</code>.`,name:"bnb_4bit_quant_type"},{anchor:"transformers.BitsAndBytesConfig.bnb_4bit_use_double_quant",description:`<strong>bnb_4bit_use_double_quant</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
This flag is used for nested quantization where the quantization constants from the first quantization are
quantized again.`,name:"bnb_4bit_use_double_quant"},{anchor:"transformers.BitsAndBytesConfig.bnb_4bit_quant_storage",description:`<strong>bnb_4bit_quant_storage</strong> (<code>torch.dtype</code> or str, <em>optional</em>, defaults to <code>torch.uint8</code>) &#x2014;
This sets the storage type to pack the quantized 4-bit params.`,name:"bnb_4bit_quant_storage"},{anchor:"transformers.BitsAndBytesConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L405"}}),ht=new b({props:{name:"is_quantizable",anchor:"transformers.BitsAndBytesConfig.is_quantizable",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L575"}}),_t=new b({props:{name:"post_init",anchor:"transformers.BitsAndBytesConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L538"}}),bt=new b({props:{name:"quantization_method",anchor:"transformers.BitsAndBytesConfig.quantization_method",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L581"}}),vt=new b({props:{name:"to_diff_dict",anchor:"transformers.BitsAndBytesConfig.to_diff_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L612",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>dict[str, Any]</code></p>
`}}),$t=new x({props:{title:"HfQuantizer",local:"transformers.quantizers.HfQuantizer",headingTag:"h2"}}),yt=new b({props:{name:"class transformers.quantizers.HfQuantizer",anchor:"transformers.quantizers.HfQuantizer",parameters:[{name:"quantization_config",val:": QuantizationConfigMixin"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L34"}}),xt=new b({props:{name:"adjust_max_memory",anchor:"transformers.quantizers.HfQuantizer.adjust_max_memory",parameters:[{name:"max_memory",val:": dict"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L181"}}),qt=new b({props:{name:"adjust_target_dtype",anchor:"transformers.quantizers.HfQuantizer.adjust_target_dtype",parameters:[{name:"dtype",val:": torch.dtype"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.adjust_target_dtype.dtype",description:`<strong>dtype</strong> (<code>torch.dtype</code>, <em>optional</em>) &#x2014;
The dtype that is used to compute the device_map.`,name:"dtype"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L109"}}),Ct=new b({props:{name:"check_quantized_param",anchor:"transformers.quantizers.HfQuantizer.check_quantized_param",parameters:[{name:"model",val:": PreTrainedModel"},{name:"param_value",val:": torch.Tensor"},{name:"param_name",val:": str"},{name:"state_dict",val:": dict"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L185"}}),zt=new b({props:{name:"create_quantized_param",anchor:"transformers.quantizers.HfQuantizer.create_quantized_param",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L200"}}),wt=new b({props:{name:"dequantize",anchor:"transformers.quantizers.HfQuantizer.dequantize",parameters:[{name:"model",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L267"}}),Tt=new b({props:{name:"get_accelerator_warm_up_factor",anchor:"transformers.quantizers.HfQuantizer.get_accelerator_warm_up_factor",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L283"}}),kt=new b({props:{name:"get_special_dtypes_update",anchor:"transformers.quantizers.HfQuantizer.get_special_dtypes_update",parameters:[{name:"model",val:""},{name:"dtype",val:": torch.dtype"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.get_special_dtypes_update.model",description:`<strong>model</strong> (<code>~transformers.PreTrainedModel</code>) &#x2014;
The model to quantize`,name:"model"},{anchor:"transformers.quantizers.HfQuantizer.get_special_dtypes_update.dtype",description:`<strong>dtype</strong> (<code>torch.dtype</code>) &#x2014;
The dtype passed in <code>from_pretrained</code> method.`,name:"dtype"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L164"}}),Pt=new b({props:{name:"get_state_dict",anchor:"transformers.quantizers.HfQuantizer.get_state_dict",parameters:[{name:"model",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L337"}}),Qt=new b({props:{name:"postprocess_model",anchor:"transformers.quantizers.HfQuantizer.postprocess_model",parameters:[{name:"model",val:": PreTrainedModel"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.postprocess_model.model",description:`<strong>model</strong> (<code>~transformers.PreTrainedModel</code>) &#x2014;
The model to quantize`,name:"model"},{anchor:"transformers.quantizers.HfQuantizer.postprocess_model.kwargs",description:`<strong>kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
The keyword arguments that are passed along <code>_process_model_after_weight_loading</code>.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L240"}}),Lt=new b({props:{name:"preprocess_model",anchor:"transformers.quantizers.HfQuantizer.preprocess_model",parameters:[{name:"model",val:": PreTrainedModel"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.preprocess_model.model",description:`<strong>model</strong> (<code>~transformers.PreTrainedModel</code>) &#x2014;
The model to quantize`,name:"model"},{anchor:"transformers.quantizers.HfQuantizer.preprocess_model.kwargs",description:`<strong>kwargs</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
The keyword arguments that are passed along <code>_process_model_before_weight_loading</code>.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L222"}}),Ht=new b({props:{name:"remove_quantization_config",anchor:"transformers.quantizers.HfQuantizer.remove_quantization_config",parameters:[{name:"model",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L253"}}),At=new b({props:{name:"update_device_map",anchor:"transformers.quantizers.HfQuantizer.update_device_map",parameters:[{name:"device_map",val:": typing.Optional[dict[str, typing.Any]]"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_device_map.device_map",description:`<strong>device_map</strong> (<code>Union[dict, str]</code>, <em>optional</em>) &#x2014;
The device_map that is passed through the <code>from_pretrained</code> method.`,name:"device_map"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L97"}}),Dt=new b({props:{name:"update_dtype",anchor:"transformers.quantizers.HfQuantizer.update_dtype",parameters:[{name:"dtype",val:": torch.dtype"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_dtype.dtype",description:`<strong>dtype</strong> (<code>torch.dtype</code>) &#x2014;
The input dtype that is passed in <code>from_pretrained</code>`,name:"dtype"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L85"}}),Mt=new b({props:{name:"update_expected_keys",anchor:"transformers.quantizers.HfQuantizer.update_expected_keys",parameters:[{name:"model",val:""},{name:"expected_keys",val:": list"},{name:"loaded_keys",val:": list"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_expected_keys.expected_keys",description:`<strong>expected_keys</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The list of the expected keys in the initialized model.`,name:"expected_keys"},{anchor:"transformers.quantizers.HfQuantizer.update_expected_keys.loaded_keys",description:`<strong>loaded_keys</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The list of the loaded keys in the checkpoint.`,name:"loaded_keys"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L152"}}),Ft=new b({props:{name:"update_missing_keys",anchor:"transformers.quantizers.HfQuantizer.update_missing_keys",parameters:[{name:"model",val:""},{name:"missing_keys",val:": list"},{name:"prefix",val:": str"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_missing_keys.missing_keys",description:`<strong>missing_keys</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The list of missing keys in the checkpoint compared to the state dict of the model`,name:"missing_keys"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L121"}}),Nt=new b({props:{name:"update_missing_keys_after_loading",anchor:"transformers.quantizers.HfQuantizer.update_missing_keys_after_loading",parameters:[{name:"model",val:""},{name:"missing_keys",val:": list"},{name:"prefix",val:": str"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_missing_keys_after_loading.missing_keys",description:`<strong>missing_keys</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The list of missing keys in the checkpoint compared to the state dict of the model`,name:"missing_keys"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L141"}}),Et=new b({props:{name:"update_param_name",anchor:"transformers.quantizers.HfQuantizer.update_param_name",parameters:[{name:"param_name",val:": str"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L299"}}),It=new b({props:{name:"update_torch_dtype",anchor:"transformers.quantizers.HfQuantizer.update_torch_dtype",parameters:[{name:"dtype",val:": torch.dtype"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_torch_dtype.dtype",description:`<strong>dtype</strong> (<code>torch.dtype</code>) &#x2014;
The input dtype that is passed in <code>from_pretrained</code>`,name:"dtype"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L72"}}),Vt=new b({props:{name:"update_tp_plan",anchor:"transformers.quantizers.HfQuantizer.update_tp_plan",parameters:[{name:"config",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L218"}}),Gt=new b({props:{name:"update_unexpected_keys",anchor:"transformers.quantizers.HfQuantizer.update_unexpected_keys",parameters:[{name:"model",val:""},{name:"unexpected_keys",val:": list"},{name:"prefix",val:": str"}],parametersDescription:[{anchor:"transformers.quantizers.HfQuantizer.update_unexpected_keys.unexpected_keys",description:`<strong>unexpected_keys</strong> (<code>list[str]</code>, <em>optional</em>) &#x2014;
The list of unexpected keys in the checkpoint compared to the state dict of the model`,name:"unexpected_keys"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L131"}}),Bt=new b({props:{name:"validate_environment",anchor:"transformers.quantizers.HfQuantizer.validate_environment",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/quantizers/base.py#L210"}}),Ot=new x({props:{title:"HiggsConfig",local:"transformers.HiggsConfig",headingTag:"h2"}}),St=new b({props:{name:"class transformers.HiggsConfig",anchor:"transformers.HiggsConfig",parameters:[{name:"bits",val:": int = 4"},{name:"p",val:": int = 2"},{name:"modules_to_not_convert",val:": typing.Optional[list[str]] = None"},{name:"hadamard_size",val:": int = 512"},{name:"group_size",val:": int = 256"},{name:"tune_metadata",val:": typing.Optional[dict[str, typing.Any]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.HiggsConfig.bits",description:`<strong>bits</strong> (int, <em>optional</em>, defaults to 4) &#x2014;
Number of bits to use for quantization. Can be 2, 3 or 4. Default is 4.`,name:"bits"},{anchor:"transformers.HiggsConfig.p",description:`<strong>p</strong> (int, <em>optional</em>, defaults to 2) &#x2014;
Quantization grid dimension. 1 and 2 are supported. 2 is always better in practice. Default is 2.`,name:"p"},{anchor:"transformers.HiggsConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to [&#x201C;lm_head&#x201D;]) &#x2014;
List of linear layers that should not be quantized.`,name:"modules_to_not_convert"},{anchor:"transformers.HiggsConfig.hadamard_size",description:`<strong>hadamard_size</strong> (int, <em>optional</em>, defaults to 512) &#x2014;
Hadamard size for the HIGGS method. Default is 512. Input dimension of matrices is padded to this value. Decreasing this below 512 will reduce the quality of the quantization.`,name:"hadamard_size"},{anchor:"transformers.HiggsConfig.group_size",description:`<strong>group_size</strong> (int, <em>optional</em>, defaults to 256) &#x2014;
Group size for the HIGGS method. Can be 64, 128 or 256. Decreasing it barely affects the performance. Default is 256. Must be a divisor of hadamard_size.`,name:"group_size"},{anchor:"transformers.HiggsConfig.tune_metadata",description:`<strong>tune_metadata</strong> (&#x2018;dict&#x2019;, <em>optional</em>, defaults to {}) &#x2014;
Module-wise metadata (gemm block shapes, GPU metadata, etc.) for saving the kernel tuning results. Default is an empty dictionary. Is set automatically during tuning.`,name:"tune_metadata"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1499"}}),Rt=new b({props:{name:"post_init",anchor:"transformers.HiggsConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1540"}}),jt=new x({props:{title:"HqqConfig",local:"transformers.HqqConfig",headingTag:"h2"}}),Wt=new b({props:{name:"class transformers.HqqConfig",anchor:"transformers.HqqConfig",parameters:[{name:"nbits",val:": int = 4"},{name:"group_size",val:": int = 64"},{name:"view_as_float",val:": bool = False"},{name:"axis",val:": typing.Optional[int] = None"},{name:"dynamic_config",val:": typing.Optional[dict] = None"},{name:"skip_modules",val:": list = ['lm_head']"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.HqqConfig.nbits",description:`<strong>nbits</strong> (<code>int</code>, <em>optional</em>, defaults to 4) &#x2014;
Number of bits. Supported values are (8, 4, 3, 2, 1).`,name:"nbits"},{anchor:"transformers.HqqConfig.group_size",description:`<strong>group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Group-size value. Supported values are any value that is divisible by weight.shape[axis]).`,name:"group_size"},{anchor:"transformers.HqqConfig.view_as_float",description:`<strong>view_as_float</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
View the quantized weight as float (used in distributed training) if set to <code>True</code>.`,name:"view_as_float"},{anchor:"transformers.HqqConfig.axis",description:`<strong>axis</strong> (<code>Optional[int]</code>, <em>optional</em>) &#x2014;
Axis along which grouping is performed. Supported values are 0 or 1.`,name:"axis"},{anchor:"transformers.HqqConfig.dynamic_config",description:`<strong>dynamic_config</strong> (dict, <em>optional</em>) &#x2014;
Parameters for dynamic configuration. The key is the name tag of the layer and the value is a quantization config.
If set, each layer specified by its id will use its dedicated quantization configuration.`,name:"dynamic_config"},{anchor:"transformers.HqqConfig.skip_modules",description:`<strong>skip_modules</strong> (<code>list[str]</code>, <em>optional</em>, defaults to <code>[&apos;lm_head&apos;]</code>) &#x2014;
List of <code>nn.Linear</code> layers to skip.`,name:"skip_modules"},{anchor:"transformers.HqqConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L280"}}),Ut=new b({props:{name:"from_dict",anchor:"transformers.HqqConfig.from_dict",parameters:[{name:"config",val:": dict"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L357"}}),Yt=new b({props:{name:"post_init",anchor:"transformers.HqqConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L351"}}),Jt=new b({props:{name:"to_diff_dict",anchor:"transformers.HqqConfig.to_diff_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L382",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>dict[str, Any]</code></p>
`}}),Xt=new x({props:{title:"Mxfp4Config",local:"transformers.Mxfp4Config",headingTag:"h2"}}),Kt=new b({props:{name:"class transformers.Mxfp4Config",anchor:"transformers.Mxfp4Config",parameters:[{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"dequantize",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.Mxfp4Config.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision.`,name:"modules_to_not_convert"},{anchor:"transformers.Mxfp4Config.dequantize",description:`<strong>dequantize</strong> (<code>bool</code>, <em>optional</em>, default to <code>False</code>) &#x2014;
Whether we dequantize the model to bf16 precision or not`,name:"dequantize"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L2055"}}),Zt=new x({props:{title:"FbgemmFp8Config",local:"transformers.FbgemmFp8Config",headingTag:"h2"}}),en=new b({props:{name:"class transformers.FbgemmFp8Config",anchor:"transformers.FbgemmFp8Config",parameters:[{name:"activation_scale_ub",val:": float = 1200.0"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FbgemmFp8Config.activation_scale_ub",description:`<strong>activation_scale_ub</strong> (<code>float</code>, <em>optional</em>, defaults to 1200.0) &#x2014;
The activation scale upper bound. This is used when quantizing the input activation.`,name:"activation_scale_ub"},{anchor:"transformers.FbgemmFp8Config.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>, default to <code>None</code>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision.`,name:"modules_to_not_convert"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1468"}}),tn=new x({props:{title:"CompressedTensorsConfig",local:"transformers.CompressedTensorsConfig",headingTag:"h2"}}),nn=new b({props:{name:"class transformers.CompressedTensorsConfig",anchor:"transformers.CompressedTensorsConfig",parameters:[{name:"config_groups",val:": typing.Optional[dict[str, typing.Union[ForwardRef('QuantizationScheme'), list[str]]]] = None"},{name:"format",val:": str = 'dense'"},{name:"quantization_status",val:": QuantizationStatus = 'initialized'"},{name:"kv_cache_scheme",val:": typing.Optional[ForwardRef('QuantizationArgs')] = None"},{name:"global_compression_ratio",val:": typing.Optional[float] = None"},{name:"ignore",val:": typing.Optional[list[str]] = None"},{name:"sparsity_config",val:": typing.Optional[dict[str, typing.Any]] = None"},{name:"quant_method",val:": str = 'compressed-tensors'"},{name:"run_compressed",val:": bool = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.CompressedTensorsConfig.config_groups",description:`<strong>config_groups</strong> (<code>typing.dict[str, typing.Union[ForwardRef(&apos;QuantizationScheme&apos;), typing.list[str]]]</code>, <em>optional</em>) &#x2014;
dictionary mapping group name to a quantization scheme definition`,name:"config_groups"},{anchor:"transformers.CompressedTensorsConfig.format",description:`<strong>format</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;dense&quot;</code>) &#x2014;
format the model is represented as. Set <code>run_compressed</code> True to execute model as the
compressed format if not <code>dense</code>`,name:"format"},{anchor:"transformers.CompressedTensorsConfig.quantization_status",description:`<strong>quantization_status</strong> (<code>QuantizationStatus</code>, <em>optional</em>, defaults to <code>&quot;initialized&quot;</code>) &#x2014;
status of model in the quantization lifecycle, ie &#x2018;initialized&#x2019;, &#x2018;calibration&#x2019;, &#x2018;frozen&#x2019;`,name:"quantization_status"},{anchor:"transformers.CompressedTensorsConfig.kv_cache_scheme",description:`<strong>kv_cache_scheme</strong> (<code>typing.Union[QuantizationArgs, NoneType]</code>, <em>optional</em>) &#x2014;
specifies quantization of the kv cache. If None, kv cache is not quantized.`,name:"kv_cache_scheme"},{anchor:"transformers.CompressedTensorsConfig.global_compression_ratio",description:`<strong>global_compression_ratio</strong> (<code>typing.Union[float, NoneType]</code>, <em>optional</em>) &#x2014;
0-1 float percentage of model compression`,name:"global_compression_ratio"},{anchor:"transformers.CompressedTensorsConfig.ignore",description:`<strong>ignore</strong> (<code>typing.Union[typing.list[str], NoneType]</code>, <em>optional</em>) &#x2014;
layer names or types to not quantize, supports regex prefixed by &#x2018;re:&#x2019;`,name:"ignore"},{anchor:"transformers.CompressedTensorsConfig.sparsity_config",description:`<strong>sparsity_config</strong> (<code>typing.dict[str, typing.Any]</code>, <em>optional</em>) &#x2014;
configuration for sparsity compression`,name:"sparsity_config"},{anchor:"transformers.CompressedTensorsConfig.quant_method",description:`<strong>quant_method</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;compressed-tensors&quot;</code>) &#x2014;
do not override, should be compressed-tensors`,name:"quant_method"},{anchor:"transformers.CompressedTensorsConfig.run_compressed",description:`<strong>run_compressed</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014; alter submodules (usually linear) in order to
emulate compressed model execution if True, otherwise use default submodule`,name:"run_compressed"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1285"}}),on=new b({props:{name:"from_dict",anchor:"transformers.CompressedTensorsConfig.from_dict",parameters:[{name:"config_dict",val:""},{name:"return_unused_kwargs",val:" = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.CompressedTensorsConfig.from_dict.config_dict",description:`<strong>config_dict</strong> (<code>dict[str, Any]</code>) &#x2014;
Dictionary that will be used to instantiate the configuration object.`,name:"config_dict"},{anchor:"transformers.CompressedTensorsConfig.from_dict.return_unused_kwargs",description:`<strong>return_unused_kwargs</strong> (<code>bool</code>,<em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to return a list of unused keyword arguments. Used for <code>from_pretrained</code> method in
<code>PreTrainedModel</code>.`,name:"return_unused_kwargs"},{anchor:"transformers.CompressedTensorsConfig.from_dict.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1372",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>The configuration object instantiated from those parameters.</p>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>QuantizationConfigMixin</code></p>
`}}),rn=new b({props:{name:"to_dict",anchor:"transformers.CompressedTensorsConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1400"}}),an=new b({props:{name:"to_diff_dict",anchor:"transformers.CompressedTensorsConfig.to_diff_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1420",returnDescription:`<script context="module">export const metadata = 'undefined';<\/script>


<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`<script context="module">export const metadata = 'undefined';<\/script>


<p><code>dict[str, Any]</code></p>
`}}),sn=new x({props:{title:"TorchAoConfig",local:"transformers.TorchAoConfig",headingTag:"h2"}}),dn=new b({props:{name:"class transformers.TorchAoConfig",anchor:"transformers.TorchAoConfig",parameters:[{name:"quant_type",val:": typing.Union[str, ForwardRef('AOBaseConfig')]"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"include_input_output_embeddings",val:": bool = False"},{name:"untie_embedding_weights",val:": bool = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1616"}}),ln=new b({props:{name:"from_dict",anchor:"transformers.TorchAoConfig.from_dict",parameters:[{name:"config_dict",val:""},{name:"return_unused_kwargs",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1828"}}),mn=new b({props:{name:"get_apply_tensor_subclass",anchor:"transformers.TorchAoConfig.get_apply_tensor_subclass",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1766"}}),cn=new b({props:{name:"post_init",anchor:"transformers.TorchAoConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1704"}}),fn=new b({props:{name:"to_dict",anchor:"transformers.TorchAoConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1800"}}),pn=new x({props:{title:"BitNetQuantConfig",local:"transformers.BitNetQuantConfig",headingTag:"h2"}}),un=new b({props:{name:"class transformers.BitNetQuantConfig",anchor:"transformers.BitNetQuantConfig",parameters:[{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"linear_class",val:": typing.Optional[str] = 'bitlinear'"},{name:"quantization_mode",val:": typing.Optional[str] = 'offline'"},{name:"use_rms_norm",val:": typing.Optional[bool] = False"},{name:"rms_norm_eps",val:": typing.Optional[float] = 1e-06"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.BitNetQuantConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>Optional[List]</code>, <em>optional</em>) &#x2014;
Optionally, provides a list of full paths of <code>nn.Linear</code> weight parameters
that shall not be quantized. Defaults to None.`,name:"modules_to_not_convert"},{anchor:"transformers.BitNetQuantConfig.linear_class",description:`<strong>linear_class</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;bitlinear&quot;</code>) &#x2014;
The type of linear class to use. Can be either <code>bitlinear</code> or <code>autobitlinear</code>.`,name:"linear_class"},{anchor:"transformers.BitNetQuantConfig.quantization_mode",description:`<strong>quantization_mode</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;offline&quot;</code>) &#x2014;
The quantization mode to use. Can be either <code>online</code> or <code>offline</code>.
In <code>online</code> mode, the weight quantization parameters are calculated dynamically
during each forward pass (e.g., based on the current weight values). This can
adapt to weight changes during training (Quantization-Aware Training - QAT).
In <code>offline</code> mode, quantization parameters are pre-calculated <em>before</em> inference.
These parameters are then fixed and loaded into the quantized model. This
generally results in lower runtime overhead compared to online quantization.`,name:"quantization_mode"},{anchor:"transformers.BitNetQuantConfig.use_rms_norm",description:`<strong>use_rms_norm</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to apply RMSNorm on the activations before quantization. This matches the original BitNet paper&#x2019;s approach
of normalizing activations before quantization/packing.`,name:"use_rms_norm"},{anchor:"transformers.BitNetQuantConfig.rms_norm_eps",description:`<strong>rms_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-06) &#x2014;
The epsilon value used in the RMSNorm layer for numerical stability.`,name:"rms_norm_eps"},{anchor:"transformers.BitNetQuantConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional keyword arguments that may be used by specific quantization
backends or future versions.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1854"}}),gn=new b({props:{name:"post_init",anchor:"transformers.BitNetQuantConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1903"}}),hn=new x({props:{title:"SpQRConfig",local:"transformers.SpQRConfig",headingTag:"h2"}}),_n=new b({props:{name:"class transformers.SpQRConfig",anchor:"transformers.SpQRConfig",parameters:[{name:"bits",val:": int = 3"},{name:"beta1",val:": int = 16"},{name:"beta2",val:": int = 16"},{name:"shapes",val:": typing.Optional[dict[str, int]] = None"},{name:"modules_to_not_convert",val:": typing.Optional[list[str]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.SpQRConfig.bits",description:`<strong>bits</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
Specifies the bit count for the weights and first order zero-points and scales.
Currently only bits = 3 is supported.`,name:"bits"},{anchor:"transformers.SpQRConfig.beta1",description:`<strong>beta1</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
SpQR tile width. Currently only beta1 = 16 is supported.`,name:"beta1"},{anchor:"transformers.SpQRConfig.beta2",description:`<strong>beta2</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
SpQR tile height. Currently only beta2 = 16 is supported.`,name:"beta2"},{anchor:"transformers.SpQRConfig.shapes",description:`<strong>shapes</strong> (<code>Optional</code>, <em>optional</em>) &#x2014;
A dictionary holding the shape of each object. We need this because it&#x2019;s impossible
to deduce the exact size of the parameters just from bits, beta1, beta2.`,name:"shapes"},{anchor:"transformers.SpQRConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>Optional[list[str]]</code>, <em>optional</em>) &#x2014;
Optionally, provides a list of full paths of <code>nn.Linear</code> weight parameters that shall not be quantized.
Defaults to None.`,name:"modules_to_not_convert"},{anchor:"transformers.SpQRConfig.kwargs",description:`<strong>kwargs</strong> (<code>dict[str, Any]</code>, <em>optional</em>) &#x2014;
Additional parameters from which to initialize the configuration object.`,name:"kwargs"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1911"}}),bn=new b({props:{name:"post_init",anchor:"transformers.SpQRConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1952"}}),vn=new x({props:{title:"FineGrainedFP8Config",local:"transformers.FineGrainedFP8Config",headingTag:"h2"}}),$n=new b({props:{name:"class transformers.FineGrainedFP8Config",anchor:"transformers.FineGrainedFP8Config",parameters:[{name:"activation_scheme",val:": str = 'dynamic'"},{name:"weight_block_size",val:": tuple = (128, 128)"},{name:"modules_to_not_convert",val:": typing.Optional[list] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FineGrainedFP8Config.activation_scheme",description:`<strong>activation_scheme</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;dynamic&quot;</code>) &#x2014;
The scheme used for activation, the defaults and only support scheme for now is &#x201C;dynamic&#x201D;.`,name:"activation_scheme"},{anchor:"transformers.FineGrainedFP8Config.weight_block_size",description:`<strong>weight_block_size</strong> (<code>typing.tuple[int, int]</code>, <em>optional</em>, defaults to <code>(128, 128)</code>) &#x2014;
The size of the weight blocks for quantization, default is (128, 128).`,name:"weight_block_size"},{anchor:"transformers.FineGrainedFP8Config.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>) &#x2014;
A list of module names that should not be converted during quantization.`,name:"modules_to_not_convert"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1974"}}),yn=new b({props:{name:"post_init",anchor:"transformers.FineGrainedFP8Config.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L2000"}}),xn=new x({props:{title:"QuarkConfig",local:"transformers.QuarkConfig",headingTag:"h2"}}),Cn=new b({props:{name:"class transformers.QuarkConfig",anchor:"transformers.QuarkConfig",parameters:[{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L2013"}}),zn=new x({props:{title:"FPQuantConfig",local:"transformers.FPQuantConfig",headingTag:"h2"}}),wn=new b({props:{name:"class transformers.FPQuantConfig",anchor:"transformers.FPQuantConfig",parameters:[{name:"forward_dtype",val:": str = 'mxfp4'"},{name:"forward_method",val:": str = 'abs_max'"},{name:"backward_dtype",val:": str = 'bf16'"},{name:"store_master_weights",val:": bool = False"},{name:"hadamard_group_size",val:": int = 32"},{name:"pseudoquantization",val:": bool = False"},{name:"modules_to_not_convert",val:": typing.Optional[list[str]] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FPQuantConfig.forward_dtype",description:`<strong>forward_dtype</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mxfp4&quot;</code>) &#x2014;
The dtype to use for the forward pass.`,name:"forward_dtype"},{anchor:"transformers.FPQuantConfig.forward_method",description:`<strong>forward_method</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;abs_max&quot;</code>) &#x2014;
The scaling to use for the forward pass. Can be <code>&quot;abs_max&quot;</code> or <code>&quot;quest&quot;</code>. <code>&quot;abs_max&quot;</code> is better for PTQ, <code>&quot;quest&quot;</code> is better for QAT.`,name:"forward_method"},{anchor:"transformers.FPQuantConfig.backward_dtype",description:`<strong>backward_dtype</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;bf16&quot;</code>) &#x2014;
The dtype to use for the backward pass.`,name:"backward_dtype"},{anchor:"transformers.FPQuantConfig.store_master_weights",description:`<strong>store_master_weights</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to store the master weights. Needed for QAT over layer weights.`,name:"store_master_weights"},{anchor:"transformers.FPQuantConfig.hadamard_group_size",description:`<strong>hadamard_group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
The group size for the hadamard transform before quantization for <code>&quot;quest&quot;</code> it matches the MXFP4 group size (32).`,name:"hadamard_group_size"},{anchor:"transformers.FPQuantConfig.pseudoquantization",description:`<strong>pseudoquantization</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use Triton-based pseudo-quantization. Is mandatory for non-Blackwell GPUs. Doesn&#x2019;t provide any speedup. For debugging purposes.`,name:"pseudoquantization"},{anchor:"transformers.FPQuantConfig.modules_to_not_convert",description:`<strong>modules_to_not_convert</strong> (<code>list</code>, <em>optional</em>) &#x2014;
The list of modules to not quantize, useful for quantizing models that explicitly require to have
some modules left in their original precision.`,name:"modules_to_not_convert"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1555"}}),Tn=new b({props:{name:"post_init",anchor:"transformers.FPQuantConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L1599"}}),kn=new x({props:{title:"AutoRoundConfig",local:"transformers.AutoRoundConfig",headingTag:"h2"}}),Pn=new b({props:{name:"class transformers.AutoRoundConfig",anchor:"transformers.AutoRoundConfig",parameters:[{name:"bits",val:": int = 4"},{name:"group_size",val:": int = 128"},{name:"sym",val:": bool = True"},{name:"backend",val:": str = 'auto'"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.AutoRoundConfig.bits",description:`<strong>bits</strong> (<code>int</code>, <em>optional</em>, defaults to 4) &#x2014;
The number of bits to quantize to, supported numbers are (2, 3, 4, 8).`,name:"bits"},{anchor:"transformers.AutoRoundConfig.group_size",description:"<strong>group_size</strong> (<code>int</code>, <em>optional</em>, defaults to 128) &#x2014; Group-size value",name:"group_size"},{anchor:"transformers.AutoRoundConfig.sym",description:"<strong>sym</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014; Symmetric quantization or not",name:"sym"},{anchor:"transformers.AutoRoundConfig.backend",description:'<strong>backend</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;auto&quot;</code>) &#x2014; The kernel to use, e.g., ipex,marlin, exllamav2, triton, etc. Ref. <a href="https://github.com/intel/auto-round?tab=readme-ov-file#specify-backend" rel="nofollow">https://github.com/intel/auto-round?tab=readme-ov-file#specify-backend</a>',name:"backend"}],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L211"}}),Qn=new b({props:{name:"post_init",anchor:"transformers.AutoRoundConfig.post_init",parameters:[],source:"https://github.com/huggingface/transformers/blob/v4.56.2/src/transformers/utils/quantization_config.py#L242"}}),Ln=new Nl({props:{source:"https://github.com/huggingface/transformers/blob/main/docs/source/en/main_classes/quantization.md"}}),{c(){q=r("meta"),Se=n(),P=r("p"),Hn=n(),d(Re.$$.fragment),mr=n(),je=r("p"),je.textContent=md,cr=n(),We=r("p"),We.innerHTML=cd,fr=n(),d(Y.$$.fragment),pr=n(),d(Ue.$$.fragment),ur=n(),Q=r("div"),d(Ye.$$.fragment),Ka=n(),An=r("p"),An.innerHTML=fd,Za=n(),J=r("div"),d(Je.$$.fragment),es=n(),Dn=r("p"),Dn.textContent=pd,gr=n(),d(Xe.$$.fragment),hr=n(),L=r("div"),d(Ke.$$.fragment),ts=n(),Mn=r("p"),Mn.innerHTML=ud,ns=n(),X=r("div"),d(Ze.$$.fragment),os=n(),Fn=r("p"),Fn.textContent=gd,_r=n(),d(et.$$.fragment),br=n(),H=r("div"),d(tt.$$.fragment),rs=n(),Nn=r("p"),Nn.innerHTML=hd,as=n(),K=r("div"),d(nt.$$.fragment),ss=n(),En=r("p"),En.textContent=_d,vr=n(),d(ot.$$.fragment),$r=n(),A=r("div"),d(rt.$$.fragment),is=n(),In=r("p"),In.innerHTML=bd,ds=n(),Z=r("div"),d(at.$$.fragment),ls=n(),Vn=r("p"),Vn.textContent=vd,yr=n(),d(st.$$.fragment),xr=n(),D=r("div"),d(it.$$.fragment),ms=n(),Gn=r("p"),Gn.innerHTML=$d,cs=n(),ee=r("div"),d(dt.$$.fragment),fs=n(),Bn=r("p"),Bn.textContent=yd,qr=n(),d(lt.$$.fragment),Cr=n(),z=r("div"),d(mt.$$.fragment),ps=n(),On=r("p"),On.innerHTML=xd,us=n(),te=r("div"),d(ct.$$.fragment),gs=n(),Sn=r("p"),Sn.textContent=qd,hs=n(),ne=r("div"),d(ft.$$.fragment),_s=n(),Rn=r("p"),Rn.textContent=Cd,bs=n(),oe=r("div"),d(pt.$$.fragment),vs=n(),jn=r("p"),jn.textContent=zd,zr=n(),d(ut.$$.fragment),wr=n(),y=r("div"),d(gt.$$.fragment),$s=n(),Wn=r("p"),Wn.innerHTML=wd,ys=n(),Un=r("p"),Un.innerHTML=Td,xs=n(),Yn=r("p"),Yn.innerHTML=kd,qs=n(),re=r("div"),d(ht.$$.fragment),Cs=n(),Jn=r("p"),Jn.innerHTML=Pd,zs=n(),ae=r("div"),d(_t.$$.fragment),ws=n(),Xn=r("p"),Xn.textContent=Qd,Ts=n(),se=r("div"),d(bt.$$.fragment),ks=n(),Kn=r("p"),Kn.innerHTML=Ld,Ps=n(),ie=r("div"),d(vt.$$.fragment),Qs=n(),Zn=r("p"),Zn.textContent=Hd,Tr=n(),d($t.$$.fragment),kr=n(),v=r("div"),d(yt.$$.fragment),Ls=n(),eo=r("p"),eo.textContent=Ad,Hs=n(),to=r("p"),to.innerHTML=Dd,As=n(),de=r("div"),d(xt.$$.fragment),Ds=n(),no=r("p"),no.textContent=Md,Ms=n(),le=r("div"),d(qt.$$.fragment),Fs=n(),oo=r("p"),oo.innerHTML=Fd,Ns=n(),me=r("div"),d(Ct.$$.fragment),Es=n(),ro=r("p"),ro.textContent=Nd,Is=n(),ce=r("div"),d(zt.$$.fragment),Vs=n(),ao=r("p"),ao.textContent=Ed,Gs=n(),fe=r("div"),d(wt.$$.fragment),Bs=n(),so=r("p"),so.textContent=Id,Os=n(),pe=r("div"),d(Tt.$$.fragment),Ss=n(),io=r("p"),io.innerHTML=Vd,Rs=n(),ue=r("div"),d(kt.$$.fragment),js=n(),lo=r("p"),lo.innerHTML=Gd,Ws=n(),ge=r("div"),d(Pt.$$.fragment),Us=n(),mo=r("p"),mo.textContent=Bd,Ys=n(),he=r("div"),d(Qt.$$.fragment),Js=n(),co=r("p"),co.innerHTML=Od,Xs=n(),_e=r("div"),d(Lt.$$.fragment),Ks=n(),fo=r("p"),fo.innerHTML=Sd,Zs=n(),be=r("div"),d(Ht.$$.fragment),ei=n(),po=r("p"),po.textContent=Rd,ti=n(),ve=r("div"),d(At.$$.fragment),ni=n(),uo=r("p"),uo.innerHTML=jd,oi=n(),$e=r("div"),d(Dt.$$.fragment),ri=n(),go=r("p"),go.textContent=Wd,ai=n(),ye=r("div"),d(Mt.$$.fragment),si=n(),ho=r("p"),ho.innerHTML=Ud,ii=n(),xe=r("div"),d(Ft.$$.fragment),di=n(),_o=r("p"),_o.innerHTML=Yd,li=n(),qe=r("div"),d(Nt.$$.fragment),mi=n(),bo=r("p"),bo.innerHTML=Jd,ci=n(),Ce=r("div"),d(Et.$$.fragment),fi=n(),vo=r("p"),vo.innerHTML=Xd,pi=n(),ze=r("div"),d(It.$$.fragment),ui=n(),$o=r("p"),$o.innerHTML=Kd,gi=n(),we=r("div"),d(Vt.$$.fragment),hi=n(),yo=r("p"),yo.textContent=Zd,_i=n(),Te=r("div"),d(Gt.$$.fragment),bi=n(),xo=r("p"),xo.innerHTML=el,vi=n(),ke=r("div"),d(Bt.$$.fragment),$i=n(),qo=r("p"),qo.innerHTML=tl,Pr=n(),d(Ot.$$.fragment),Qr=n(),M=r("div"),d(St.$$.fragment),yi=n(),Co=r("p"),Co.textContent=nl,xi=n(),Pe=r("div"),d(Rt.$$.fragment),qi=n(),zo=r("p"),zo.textContent=ol,Lr=n(),d(jt.$$.fragment),Hr=n(),w=r("div"),d(Wt.$$.fragment),Ci=n(),wo=r("p"),wo.textContent=rl,zi=n(),Qe=r("div"),d(Ut.$$.fragment),wi=n(),To=r("p"),To.textContent=al,Ti=n(),Le=r("div"),d(Yt.$$.fragment),ki=n(),ko=r("p"),ko.textContent=sl,Pi=n(),He=r("div"),d(Jt.$$.fragment),Qi=n(),Po=r("p"),Po.textContent=il,Ar=n(),d(Xt.$$.fragment),Dr=n(),j=r("div"),d(Kt.$$.fragment),Li=n(),Qo=r("p"),Qo.textContent=dl,Mr=n(),d(Zt.$$.fragment),Fr=n(),W=r("div"),d(en.$$.fragment),Hi=n(),Lo=r("p"),Lo.textContent=ll,Nr=n(),d(tn.$$.fragment),Er=n(),T=r("div"),d(nn.$$.fragment),Ai=n(),Ho=r("p"),Ho.innerHTML=ml,Di=n(),Ae=r("div"),d(on.$$.fragment),Mi=n(),Ao=r("p"),Ao.innerHTML=cl,Fi=n(),G=r("div"),d(rn.$$.fragment),Ni=n(),Do=r("p"),Do.textContent=fl,Ei=n(),Mo=r("p"),Mo.innerHTML=pl,Ii=n(),De=r("div"),d(an.$$.fragment),Vi=n(),Fo=r("p"),Fo.textContent=ul,Ir=n(),d(sn.$$.fragment),Vr=n(),k=r("div"),d(dn.$$.fragment),Gi=n(),Me=r("div"),d(ln.$$.fragment),Bi=n(),No=r("p"),No.textContent=gl,Oi=n(),Fe=r("div"),d(mn.$$.fragment),Si=n(),Eo=r("p"),Eo.textContent=hl,Ri=n(),Ne=r("div"),d(cn.$$.fragment),ji=n(),Io=r("p"),Io.textContent=_l,Wi=n(),Ee=r("div"),d(fn.$$.fragment),Ui=n(),Vo=r("p"),Vo.textContent=bl,Gr=n(),d(pn.$$.fragment),Br=n(),F=r("div"),d(un.$$.fragment),Yi=n(),Go=r("p"),Go.textContent=vl,Ji=n(),Ie=r("div"),d(gn.$$.fragment),Xi=n(),Bo=r("p"),Bo.textContent=$l,Or=n(),d(hn.$$.fragment),Sr=n(),N=r("div"),d(_n.$$.fragment),Ki=n(),Oo=r("p"),Oo.innerHTML=yl,Zi=n(),Ve=r("div"),d(bn.$$.fragment),ed=n(),So=r("p"),So.textContent=xl,Rr=n(),d(vn.$$.fragment),jr=n(),E=r("div"),d($n.$$.fragment),td=n(),Ro=r("p"),Ro.textContent=ql,nd=n(),Ge=r("div"),d(yn.$$.fragment),od=n(),jo=r("p"),jo.textContent=Cl,Wr=n(),d(xn.$$.fragment),Ur=n(),qn=r("div"),d(Cn.$$.fragment),Yr=n(),d(zn.$$.fragment),Jr=n(),I=r("div"),d(wn.$$.fragment),rd=n(),Wo=r("p"),Wo.textContent=zl,ad=n(),Be=r("div"),d(Tn.$$.fragment),sd=n(),Uo=r("p"),Uo.textContent=wl,Xr=n(),d(kn.$$.fragment),Kr=n(),V=r("div"),d(Pn.$$.fragment),id=n(),Yo=r("p"),Yo.textContent=Tl,dd=n(),Oe=r("div"),d(Qn.$$.fragment),ld=n(),Jo=r("p"),Jo.textContent=kl,Zr=n(),d(Ln.$$.fragment),ea=n(),dr=r("p"),this.h()},l(e){const i=Ml("svelte-u9bgzb",document.head);q=a(i,"META",{name:!0,content:!0}),i.forEach(s),Se=o(e),P=a(e,"P",{}),h(P).forEach(s),Hn=o(e),l(Re.$$.fragment,e),mr=o(e),je=a(e,"P",{"data-svelte-h":!0}),u(je)!=="svelte-1hsjm7z"&&(je.textContent=md),cr=o(e),We=a(e,"P",{"data-svelte-h":!0}),u(We)!=="svelte-bnel0f"&&(We.innerHTML=cd),fr=o(e),l(Y.$$.fragment,e),pr=o(e),l(Ue.$$.fragment,e),ur=o(e),Q=a(e,"DIV",{class:!0});var U=h(Q);l(Ye.$$.fragment,U),Ka=o(U),An=a(U,"P",{"data-svelte-h":!0}),u(An)!=="svelte-b8v0f"&&(An.innerHTML=fd),Za=o(U),J=a(U,"DIV",{class:!0});var na=h(J);l(Je.$$.fragment,na),es=o(na),Dn=a(na,"P",{"data-svelte-h":!0}),u(Dn)!=="svelte-1ozftb6"&&(Dn.textContent=pd),na.forEach(s),U.forEach(s),gr=o(e),l(Xe.$$.fragment,e),hr=o(e),L=a(e,"DIV",{class:!0});var Xo=h(L);l(Ke.$$.fragment,Xo),ts=o(Xo),Mn=a(Xo,"P",{"data-svelte-h":!0}),u(Mn)!=="svelte-1s7ccdx"&&(Mn.innerHTML=ud),ns=o(Xo),X=a(Xo,"DIV",{class:!0});var oa=h(X);l(Ze.$$.fragment,oa),os=o(oa),Fn=a(oa,"P",{"data-svelte-h":!0}),u(Fn)!=="svelte-gy26u4"&&(Fn.textContent=gd),oa.forEach(s),Xo.forEach(s),_r=o(e),l(et.$$.fragment,e),br=o(e),H=a(e,"DIV",{class:!0});var Ko=h(H);l(tt.$$.fragment,Ko),rs=o(Ko),Nn=a(Ko,"P",{"data-svelte-h":!0}),u(Nn)!=="svelte-w1pax1"&&(Nn.innerHTML=hd),as=o(Ko),K=a(Ko,"DIV",{class:!0});var ra=h(K);l(nt.$$.fragment,ra),ss=o(ra),En=a(ra,"P",{"data-svelte-h":!0}),u(En)!=="svelte-1ozftb6"&&(En.textContent=_d),ra.forEach(s),Ko.forEach(s),vr=o(e),l(ot.$$.fragment,e),$r=o(e),A=a(e,"DIV",{class:!0});var Zo=h(A);l(rt.$$.fragment,Zo),is=o(Zo),In=a(Zo,"P",{"data-svelte-h":!0}),u(In)!=="svelte-1i667it"&&(In.innerHTML=bd),ds=o(Zo),Z=a(Zo,"DIV",{class:!0});var aa=h(Z);l(at.$$.fragment,aa),ls=o(aa),Vn=a(aa,"P",{"data-svelte-h":!0}),u(Vn)!=="svelte-1ozftb6"&&(Vn.textContent=vd),aa.forEach(s),Zo.forEach(s),yr=o(e),l(st.$$.fragment,e),xr=o(e),D=a(e,"DIV",{class:!0});var er=h(D);l(it.$$.fragment,er),ms=o(er),Gn=a(er,"P",{"data-svelte-h":!0}),u(Gn)!=="svelte-438k9a"&&(Gn.innerHTML=$d),cs=o(er),ee=a(er,"DIV",{class:!0});var sa=h(ee);l(dt.$$.fragment,sa),fs=o(sa),Bn=a(sa,"P",{"data-svelte-h":!0}),u(Bn)!=="svelte-1ozftb6"&&(Bn.textContent=yd),sa.forEach(s),er.forEach(s),qr=o(e),l(lt.$$.fragment,e),Cr=o(e),z=a(e,"DIV",{class:!0});var B=h(z);l(mt.$$.fragment,B),ps=o(B),On=a(B,"P",{"data-svelte-h":!0}),u(On)!=="svelte-i3efvr"&&(On.innerHTML=xd),us=o(B),te=a(B,"DIV",{class:!0});var ia=h(te);l(ct.$$.fragment,ia),gs=o(ia),Sn=a(ia,"P",{"data-svelte-h":!0}),u(Sn)!=="svelte-4jdj2l"&&(Sn.textContent=qd),ia.forEach(s),hs=o(B),ne=a(B,"DIV",{class:!0});var da=h(ne);l(ft.$$.fragment,da),_s=o(da),Rn=a(da,"P",{"data-svelte-h":!0}),u(Rn)!=="svelte-1ozftb6"&&(Rn.textContent=Cd),da.forEach(s),bs=o(B),oe=a(B,"DIV",{class:!0});var la=h(oe);l(pt.$$.fragment,la),vs=o(la),jn=a(la,"P",{"data-svelte-h":!0}),u(jn)!=="svelte-pjgtd6"&&(jn.textContent=zd),la.forEach(s),B.forEach(s),zr=o(e),l(ut.$$.fragment,e),wr=o(e),y=a(e,"DIV",{class:!0});var C=h(y);l(gt.$$.fragment,C),$s=o(C),Wn=a(C,"P",{"data-svelte-h":!0}),u(Wn)!=="svelte-woamwr"&&(Wn.innerHTML=wd),ys=o(C),Un=a(C,"P",{"data-svelte-h":!0}),u(Un)!=="svelte-ki5gis"&&(Un.innerHTML=Td),xs=o(C),Yn=a(C,"P",{"data-svelte-h":!0}),u(Yn)!=="svelte-8qsk2q"&&(Yn.innerHTML=kd),qs=o(C),re=a(C,"DIV",{class:!0});var ma=h(re);l(ht.$$.fragment,ma),Cs=o(ma),Jn=a(ma,"P",{"data-svelte-h":!0}),u(Jn)!=="svelte-10tvzyv"&&(Jn.innerHTML=Pd),ma.forEach(s),zs=o(C),ae=a(C,"DIV",{class:!0});var ca=h(ae);l(_t.$$.fragment,ca),ws=o(ca),Xn=a(ca,"P",{"data-svelte-h":!0}),u(Xn)!=="svelte-gy26u4"&&(Xn.textContent=Qd),ca.forEach(s),Ts=o(C),se=a(C,"DIV",{class:!0});var fa=h(se);l(bt.$$.fragment,fa),ks=o(fa),Kn=a(fa,"P",{"data-svelte-h":!0}),u(Kn)!=="svelte-19bn0da"&&(Kn.innerHTML=Ld),fa.forEach(s),Ps=o(C),ie=a(C,"DIV",{class:!0});var pa=h(ie);l(vt.$$.fragment,pa),Qs=o(pa),Zn=a(pa,"P",{"data-svelte-h":!0}),u(Zn)!=="svelte-1p6bdas"&&(Zn.textContent=Hd),pa.forEach(s),C.forEach(s),Tr=o(e),l($t.$$.fragment,e),kr=o(e),v=a(e,"DIV",{class:!0});var $=h(v);l(yt.$$.fragment,$),Ls=o($),eo=a($,"P",{"data-svelte-h":!0}),u(eo)!=="svelte-1xvcahi"&&(eo.textContent=Ad),Hs=o($),to=a($,"P",{"data-svelte-h":!0}),u(to)!=="svelte-3vnb45"&&(to.innerHTML=Dd),As=o($),de=a($,"DIV",{class:!0});var ua=h(de);l(xt.$$.fragment,ua),Ds=o(ua),no=a(ua,"P",{"data-svelte-h":!0}),u(no)!=="svelte-1d4i4z7"&&(no.textContent=Md),ua.forEach(s),Ms=o($),le=a($,"DIV",{class:!0});var ga=h(le);l(qt.$$.fragment,ga),Fs=o(ga),oo=a(ga,"P",{"data-svelte-h":!0}),u(oo)!=="svelte-4t526i"&&(oo.innerHTML=Fd),ga.forEach(s),Ns=o($),me=a($,"DIV",{class:!0});var ha=h(me);l(Ct.$$.fragment,ha),Es=o(ha),ro=a(ha,"P",{"data-svelte-h":!0}),u(ro)!=="svelte-1meey31"&&(ro.textContent=Nd),ha.forEach(s),Is=o($),ce=a($,"DIV",{class:!0});var _a=h(ce);l(zt.$$.fragment,_a),Vs=o(_a),ao=a(_a,"P",{"data-svelte-h":!0}),u(ao)!=="svelte-1j1vsi1"&&(ao.textContent=Ed),_a.forEach(s),Gs=o($),fe=a($,"DIV",{class:!0});var ba=h(fe);l(wt.$$.fragment,ba),Bs=o(ba),so=a(ba,"P",{"data-svelte-h":!0}),u(so)!=="svelte-xh29gb"&&(so.textContent=Id),ba.forEach(s),Os=o($),pe=a($,"DIV",{class:!0});var va=h(pe);l(Tt.$$.fragment,va),Ss=o(va),io=a(va,"P",{"data-svelte-h":!0}),u(io)!=="svelte-hxwqed"&&(io.innerHTML=Vd),va.forEach(s),Rs=o($),ue=a($,"DIV",{class:!0});var $a=h(ue);l(kt.$$.fragment,$a),js=o($a),lo=a($a,"P",{"data-svelte-h":!0}),u(lo)!=="svelte-i8h8td"&&(lo.innerHTML=Gd),$a.forEach(s),Ws=o($),ge=a($,"DIV",{class:!0});var ya=h(ge);l(Pt.$$.fragment,ya),Us=o(ya),mo=a(ya,"P",{"data-svelte-h":!0}),u(mo)!=="svelte-8a1lyi"&&(mo.textContent=Bd),ya.forEach(s),Ys=o($),he=a($,"DIV",{class:!0});var xa=h(he);l(Qt.$$.fragment,xa),Js=o(xa),co=a(xa,"P",{"data-svelte-h":!0}),u(co)!=="svelte-1uznum5"&&(co.innerHTML=Od),xa.forEach(s),Xs=o($),_e=a($,"DIV",{class:!0});var qa=h(_e);l(Lt.$$.fragment,qa),Ks=o(qa),fo=a(qa,"P",{"data-svelte-h":!0}),u(fo)!=="svelte-mjhdcv"&&(fo.innerHTML=Sd),qa.forEach(s),Zs=o($),be=a($,"DIV",{class:!0});var Ca=h(be);l(Ht.$$.fragment,Ca),ei=o(Ca),po=a(Ca,"P",{"data-svelte-h":!0}),u(po)!=="svelte-52re82"&&(po.textContent=Rd),Ca.forEach(s),ti=o($),ve=a($,"DIV",{class:!0});var za=h(ve);l(At.$$.fragment,za),ni=o(za),uo=a(za,"P",{"data-svelte-h":!0}),u(uo)!=="svelte-1e5epn5"&&(uo.innerHTML=jd),za.forEach(s),oi=o($),$e=a($,"DIV",{class:!0});var wa=h($e);l(Dt.$$.fragment,wa),ri=o(wa),go=a(wa,"P",{"data-svelte-h":!0}),u(go)!=="svelte-1kpdm09"&&(go.textContent=Wd),wa.forEach(s),ai=o($),ye=a($,"DIV",{class:!0});var Ta=h(ye);l(Mt.$$.fragment,Ta),si=o(Ta),ho=a(Ta,"P",{"data-svelte-h":!0}),u(ho)!=="svelte-1idnt2e"&&(ho.innerHTML=Ud),Ta.forEach(s),ii=o($),xe=a($,"DIV",{class:!0});var ka=h(xe);l(Ft.$$.fragment,ka),di=o(ka),_o=a(ka,"P",{"data-svelte-h":!0}),u(_o)!=="svelte-13hqoy0"&&(_o.innerHTML=Yd),ka.forEach(s),li=o($),qe=a($,"DIV",{class:!0});var Pa=h(qe);l(Nt.$$.fragment,Pa),mi=o(Pa),bo=a(Pa,"P",{"data-svelte-h":!0}),u(bo)!=="svelte-jj28f7"&&(bo.innerHTML=Jd),Pa.forEach(s),ci=o($),Ce=a($,"DIV",{class:!0});var Qa=h(Ce);l(Et.$$.fragment,Qa),fi=o(Qa),vo=a(Qa,"P",{"data-svelte-h":!0}),u(vo)!=="svelte-9oke74"&&(vo.innerHTML=Xd),Qa.forEach(s),pi=o($),ze=a($,"DIV",{class:!0});var La=h(ze);l(It.$$.fragment,La),ui=o(La),$o=a(La,"P",{"data-svelte-h":!0}),u($o)!=="svelte-3onz4n"&&($o.innerHTML=Kd),La.forEach(s),gi=o($),we=a($,"DIV",{class:!0});var Ha=h(we);l(Vt.$$.fragment,Ha),hi=o(Ha),yo=a(Ha,"P",{"data-svelte-h":!0}),u(yo)!=="svelte-114nk8f"&&(yo.textContent=Zd),Ha.forEach(s),_i=o($),Te=a($,"DIV",{class:!0});var Aa=h(Te);l(Gt.$$.fragment,Aa),bi=o(Aa),xo=a(Aa,"P",{"data-svelte-h":!0}),u(xo)!=="svelte-o8fcb9"&&(xo.innerHTML=el),Aa.forEach(s),vi=o($),ke=a($,"DIV",{class:!0});var Da=h(ke);l(Bt.$$.fragment,Da),$i=o(Da),qo=a(Da,"P",{"data-svelte-h":!0}),u(qo)!=="svelte-1lxocan"&&(qo.innerHTML=tl),Da.forEach(s),$.forEach(s),Pr=o(e),l(Ot.$$.fragment,e),Qr=o(e),M=a(e,"DIV",{class:!0});var tr=h(M);l(St.$$.fragment,tr),yi=o(tr),Co=a(tr,"P",{"data-svelte-h":!0}),u(Co)!=="svelte-i9o5pz"&&(Co.textContent=nl),xi=o(tr),Pe=a(tr,"DIV",{class:!0});var Ma=h(Pe);l(Rt.$$.fragment,Ma),qi=o(Ma),zo=a(Ma,"P",{"data-svelte-h":!0}),u(zo)!=="svelte-gy26u4"&&(zo.textContent=ol),Ma.forEach(s),tr.forEach(s),Lr=o(e),l(jt.$$.fragment,e),Hr=o(e),w=a(e,"DIV",{class:!0});var O=h(w);l(Wt.$$.fragment,O),Ci=o(O),wo=a(O,"P",{"data-svelte-h":!0}),u(wo)!=="svelte-h0fjpw"&&(wo.textContent=rl),zi=o(O),Qe=a(O,"DIV",{class:!0});var Fa=h(Qe);l(Ut.$$.fragment,Fa),wi=o(Fa),To=a(Fa,"P",{"data-svelte-h":!0}),u(To)!=="svelte-6lcv9o"&&(To.textContent=al),Fa.forEach(s),Ti=o(O),Le=a(O,"DIV",{class:!0});var Na=h(Le);l(Yt.$$.fragment,Na),ki=o(Na),ko=a(Na,"P",{"data-svelte-h":!0}),u(ko)!=="svelte-gy26u4"&&(ko.textContent=sl),Na.forEach(s),Pi=o(O),He=a(O,"DIV",{class:!0});var Ea=h(He);l(Jt.$$.fragment,Ea),Qi=o(Ea),Po=a(Ea,"P",{"data-svelte-h":!0}),u(Po)!=="svelte-1p6bdas"&&(Po.textContent=il),Ea.forEach(s),O.forEach(s),Ar=o(e),l(Xt.$$.fragment,e),Dr=o(e),j=a(e,"DIV",{class:!0});var Ia=h(j);l(Kt.$$.fragment,Ia),Li=o(Ia),Qo=a(Ia,"P",{"data-svelte-h":!0}),u(Qo)!=="svelte-1l0x8di"&&(Qo.textContent=dl),Ia.forEach(s),Mr=o(e),l(Zt.$$.fragment,e),Fr=o(e),W=a(e,"DIV",{class:!0});var Va=h(W);l(en.$$.fragment,Va),Hi=o(Va),Lo=a(Va,"P",{"data-svelte-h":!0}),u(Lo)!=="svelte-1a51md3"&&(Lo.textContent=ll),Va.forEach(s),Nr=o(e),l(tn.$$.fragment,e),Er=o(e),T=a(e,"DIV",{class:!0});var S=h(T);l(nn.$$.fragment,S),Ai=o(S),Ho=a(S,"P",{"data-svelte-h":!0}),u(Ho)!=="svelte-3h2fkj"&&(Ho.innerHTML=ml),Di=o(S),Ae=a(S,"DIV",{class:!0});var Ga=h(Ae);l(on.$$.fragment,Ga),Mi=o(Ga),Ao=a(Ga,"P",{"data-svelte-h":!0}),u(Ao)!=="svelte-1nb5gj0"&&(Ao.innerHTML=cl),Ga.forEach(s),Fi=o(S),G=a(S,"DIV",{class:!0});var nr=h(G);l(rn.$$.fragment,nr),Ni=o(nr),Do=a(nr,"P",{"data-svelte-h":!0}),u(Do)!=="svelte-1h5q4kg"&&(Do.textContent=fl),Ei=o(nr),Mo=a(nr,"P",{"data-svelte-h":!0}),u(Mo)!=="svelte-hk9iaa"&&(Mo.innerHTML=pl),nr.forEach(s),Ii=o(S),De=a(S,"DIV",{class:!0});var Ba=h(De);l(an.$$.fragment,Ba),Vi=o(Ba),Fo=a(Ba,"P",{"data-svelte-h":!0}),u(Fo)!=="svelte-1p6bdas"&&(Fo.textContent=ul),Ba.forEach(s),S.forEach(s),Ir=o(e),l(sn.$$.fragment,e),Vr=o(e),k=a(e,"DIV",{class:!0});var R=h(k);l(dn.$$.fragment,R),Gi=o(R),Me=a(R,"DIV",{class:!0});var Oa=h(Me);l(ln.$$.fragment,Oa),Bi=o(Oa),No=a(Oa,"P",{"data-svelte-h":!0}),u(No)!=="svelte-x30fz7"&&(No.textContent=gl),Oa.forEach(s),Oi=o(R),Fe=a(R,"DIV",{class:!0});var Sa=h(Fe);l(mn.$$.fragment,Sa),Si=o(Sa),Eo=a(Sa,"P",{"data-svelte-h":!0}),u(Eo)!=="svelte-1gkr97u"&&(Eo.textContent=hl),Sa.forEach(s),Ri=o(R),Ne=a(R,"DIV",{class:!0});var Ra=h(Ne);l(cn.$$.fragment,Ra),ji=o(Ra),Io=a(Ra,"P",{"data-svelte-h":!0}),u(Io)!=="svelte-ewtypr"&&(Io.textContent=_l),Ra.forEach(s),Wi=o(R),Ee=a(R,"DIV",{class:!0});var ja=h(Ee);l(fn.$$.fragment,ja),Ui=o(ja),Vo=a(ja,"P",{"data-svelte-h":!0}),u(Vo)!=="svelte-11q54ot"&&(Vo.textContent=bl),ja.forEach(s),R.forEach(s),Gr=o(e),l(pn.$$.fragment,e),Br=o(e),F=a(e,"DIV",{class:!0});var or=h(F);l(un.$$.fragment,or),Yi=o(or),Go=a(or,"P",{"data-svelte-h":!0}),u(Go)!=="svelte-tlgice"&&(Go.textContent=vl),Ji=o(or),Ie=a(or,"DIV",{class:!0});var Wa=h(Ie);l(gn.$$.fragment,Wa),Xi=o(Wa),Bo=a(Wa,"P",{"data-svelte-h":!0}),u(Bo)!=="svelte-1ozftb6"&&(Bo.textContent=$l),Wa.forEach(s),or.forEach(s),Or=o(e),l(hn.$$.fragment,e),Sr=o(e),N=a(e,"DIV",{class:!0});var rr=h(N);l(_n.$$.fragment,rr),Ki=o(rr),Oo=a(rr,"P",{"data-svelte-h":!0}),u(Oo)!=="svelte-1sf4vkr"&&(Oo.innerHTML=yl),Zi=o(rr),Ve=a(rr,"DIV",{class:!0});var Ua=h(Ve);l(bn.$$.fragment,Ua),ed=o(Ua),So=a(Ua,"P",{"data-svelte-h":!0}),u(So)!=="svelte-gy26u4"&&(So.textContent=xl),Ua.forEach(s),rr.forEach(s),Rr=o(e),l(vn.$$.fragment,e),jr=o(e),E=a(e,"DIV",{class:!0});var ar=h(E);l($n.$$.fragment,ar),td=o(ar),Ro=a(ar,"P",{"data-svelte-h":!0}),u(Ro)!=="svelte-1inuoy"&&(Ro.textContent=ql),nd=o(ar),Ge=a(ar,"DIV",{class:!0});var Ya=h(Ge);l(yn.$$.fragment,Ya),od=o(Ya),jo=a(Ya,"P",{"data-svelte-h":!0}),u(jo)!=="svelte-1ozftb6"&&(jo.textContent=Cl),Ya.forEach(s),ar.forEach(s),Wr=o(e),l(xn.$$.fragment,e),Ur=o(e),qn=a(e,"DIV",{class:!0});var Pl=h(qn);l(Cn.$$.fragment,Pl),Pl.forEach(s),Yr=o(e),l(zn.$$.fragment,e),Jr=o(e),I=a(e,"DIV",{class:!0});var sr=h(I);l(wn.$$.fragment,sr),rd=o(sr),Wo=a(sr,"P",{"data-svelte-h":!0}),u(Wo)!=="svelte-1y1kjvj"&&(Wo.textContent=zl),ad=o(sr),Be=a(sr,"DIV",{class:!0});var Ja=h(Be);l(Tn.$$.fragment,Ja),sd=o(Ja),Uo=a(Ja,"P",{"data-svelte-h":!0}),u(Uo)!=="svelte-gy26u4"&&(Uo.textContent=wl),Ja.forEach(s),sr.forEach(s),Xr=o(e),l(kn.$$.fragment,e),Kr=o(e),V=a(e,"DIV",{class:!0});var ir=h(V);l(Pn.$$.fragment,ir),id=o(ir),Yo=a(ir,"P",{"data-svelte-h":!0}),u(Yo)!=="svelte-g63l5u"&&(Yo.textContent=Tl),dd=o(ir),Oe=a(ir,"DIV",{class:!0});var Xa=h(Oe);l(Qn.$$.fragment,Xa),ld=o(Xa),Jo=a(Xa,"P",{"data-svelte-h":!0}),u(Jo)!=="svelte-prp48c"&&(Jo.textContent=kl),Xa.forEach(s),ir.forEach(s),Zr=o(e),l(Ln.$$.fragment,e),ea=o(e),dr=a(e,"P",{}),h(dr).forEach(s),this.h()},h(){_(q,"name","hf:doc:metadata"),_(q,"content",Vl),_(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(v,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(He,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(w,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(W,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(k,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(qn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),_(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(e,i){t(document.head,q),g(e,Se,i),g(e,P,i),g(e,Hn,i),m(Re,e,i),g(e,mr,i),g(e,je,i),g(e,cr,i),g(e,We,i),g(e,fr,i),m(Y,e,i),g(e,pr,i),m(Ue,e,i),g(e,ur,i),g(e,Q,i),m(Ye,Q,null),t(Q,Ka),t(Q,An),t(Q,Za),t(Q,J),m(Je,J,null),t(J,es),t(J,Dn),g(e,gr,i),m(Xe,e,i),g(e,hr,i),g(e,L,i),m(Ke,L,null),t(L,ts),t(L,Mn),t(L,ns),t(L,X),m(Ze,X,null),t(X,os),t(X,Fn),g(e,_r,i),m(et,e,i),g(e,br,i),g(e,H,i),m(tt,H,null),t(H,rs),t(H,Nn),t(H,as),t(H,K),m(nt,K,null),t(K,ss),t(K,En),g(e,vr,i),m(ot,e,i),g(e,$r,i),g(e,A,i),m(rt,A,null),t(A,is),t(A,In),t(A,ds),t(A,Z),m(at,Z,null),t(Z,ls),t(Z,Vn),g(e,yr,i),m(st,e,i),g(e,xr,i),g(e,D,i),m(it,D,null),t(D,ms),t(D,Gn),t(D,cs),t(D,ee),m(dt,ee,null),t(ee,fs),t(ee,Bn),g(e,qr,i),m(lt,e,i),g(e,Cr,i),g(e,z,i),m(mt,z,null),t(z,ps),t(z,On),t(z,us),t(z,te),m(ct,te,null),t(te,gs),t(te,Sn),t(z,hs),t(z,ne),m(ft,ne,null),t(ne,_s),t(ne,Rn),t(z,bs),t(z,oe),m(pt,oe,null),t(oe,vs),t(oe,jn),g(e,zr,i),m(ut,e,i),g(e,wr,i),g(e,y,i),m(gt,y,null),t(y,$s),t(y,Wn),t(y,ys),t(y,Un),t(y,xs),t(y,Yn),t(y,qs),t(y,re),m(ht,re,null),t(re,Cs),t(re,Jn),t(y,zs),t(y,ae),m(_t,ae,null),t(ae,ws),t(ae,Xn),t(y,Ts),t(y,se),m(bt,se,null),t(se,ks),t(se,Kn),t(y,Ps),t(y,ie),m(vt,ie,null),t(ie,Qs),t(ie,Zn),g(e,Tr,i),m($t,e,i),g(e,kr,i),g(e,v,i),m(yt,v,null),t(v,Ls),t(v,eo),t(v,Hs),t(v,to),t(v,As),t(v,de),m(xt,de,null),t(de,Ds),t(de,no),t(v,Ms),t(v,le),m(qt,le,null),t(le,Fs),t(le,oo),t(v,Ns),t(v,me),m(Ct,me,null),t(me,Es),t(me,ro),t(v,Is),t(v,ce),m(zt,ce,null),t(ce,Vs),t(ce,ao),t(v,Gs),t(v,fe),m(wt,fe,null),t(fe,Bs),t(fe,so),t(v,Os),t(v,pe),m(Tt,pe,null),t(pe,Ss),t(pe,io),t(v,Rs),t(v,ue),m(kt,ue,null),t(ue,js),t(ue,lo),t(v,Ws),t(v,ge),m(Pt,ge,null),t(ge,Us),t(ge,mo),t(v,Ys),t(v,he),m(Qt,he,null),t(he,Js),t(he,co),t(v,Xs),t(v,_e),m(Lt,_e,null),t(_e,Ks),t(_e,fo),t(v,Zs),t(v,be),m(Ht,be,null),t(be,ei),t(be,po),t(v,ti),t(v,ve),m(At,ve,null),t(ve,ni),t(ve,uo),t(v,oi),t(v,$e),m(Dt,$e,null),t($e,ri),t($e,go),t(v,ai),t(v,ye),m(Mt,ye,null),t(ye,si),t(ye,ho),t(v,ii),t(v,xe),m(Ft,xe,null),t(xe,di),t(xe,_o),t(v,li),t(v,qe),m(Nt,qe,null),t(qe,mi),t(qe,bo),t(v,ci),t(v,Ce),m(Et,Ce,null),t(Ce,fi),t(Ce,vo),t(v,pi),t(v,ze),m(It,ze,null),t(ze,ui),t(ze,$o),t(v,gi),t(v,we),m(Vt,we,null),t(we,hi),t(we,yo),t(v,_i),t(v,Te),m(Gt,Te,null),t(Te,bi),t(Te,xo),t(v,vi),t(v,ke),m(Bt,ke,null),t(ke,$i),t(ke,qo),g(e,Pr,i),m(Ot,e,i),g(e,Qr,i),g(e,M,i),m(St,M,null),t(M,yi),t(M,Co),t(M,xi),t(M,Pe),m(Rt,Pe,null),t(Pe,qi),t(Pe,zo),g(e,Lr,i),m(jt,e,i),g(e,Hr,i),g(e,w,i),m(Wt,w,null),t(w,Ci),t(w,wo),t(w,zi),t(w,Qe),m(Ut,Qe,null),t(Qe,wi),t(Qe,To),t(w,Ti),t(w,Le),m(Yt,Le,null),t(Le,ki),t(Le,ko),t(w,Pi),t(w,He),m(Jt,He,null),t(He,Qi),t(He,Po),g(e,Ar,i),m(Xt,e,i),g(e,Dr,i),g(e,j,i),m(Kt,j,null),t(j,Li),t(j,Qo),g(e,Mr,i),m(Zt,e,i),g(e,Fr,i),g(e,W,i),m(en,W,null),t(W,Hi),t(W,Lo),g(e,Nr,i),m(tn,e,i),g(e,Er,i),g(e,T,i),m(nn,T,null),t(T,Ai),t(T,Ho),t(T,Di),t(T,Ae),m(on,Ae,null),t(Ae,Mi),t(Ae,Ao),t(T,Fi),t(T,G),m(rn,G,null),t(G,Ni),t(G,Do),t(G,Ei),t(G,Mo),t(T,Ii),t(T,De),m(an,De,null),t(De,Vi),t(De,Fo),g(e,Ir,i),m(sn,e,i),g(e,Vr,i),g(e,k,i),m(dn,k,null),t(k,Gi),t(k,Me),m(ln,Me,null),t(Me,Bi),t(Me,No),t(k,Oi),t(k,Fe),m(mn,Fe,null),t(Fe,Si),t(Fe,Eo),t(k,Ri),t(k,Ne),m(cn,Ne,null),t(Ne,ji),t(Ne,Io),t(k,Wi),t(k,Ee),m(fn,Ee,null),t(Ee,Ui),t(Ee,Vo),g(e,Gr,i),m(pn,e,i),g(e,Br,i),g(e,F,i),m(un,F,null),t(F,Yi),t(F,Go),t(F,Ji),t(F,Ie),m(gn,Ie,null),t(Ie,Xi),t(Ie,Bo),g(e,Or,i),m(hn,e,i),g(e,Sr,i),g(e,N,i),m(_n,N,null),t(N,Ki),t(N,Oo),t(N,Zi),t(N,Ve),m(bn,Ve,null),t(Ve,ed),t(Ve,So),g(e,Rr,i),m(vn,e,i),g(e,jr,i),g(e,E,i),m($n,E,null),t(E,td),t(E,Ro),t(E,nd),t(E,Ge),m(yn,Ge,null),t(Ge,od),t(Ge,jo),g(e,Wr,i),m(xn,e,i),g(e,Ur,i),g(e,qn,i),m(Cn,qn,null),g(e,Yr,i),m(zn,e,i),g(e,Jr,i),g(e,I,i),m(wn,I,null),t(I,rd),t(I,Wo),t(I,ad),t(I,Be),m(Tn,Be,null),t(Be,sd),t(Be,Uo),g(e,Xr,i),m(kn,e,i),g(e,Kr,i),g(e,V,i),m(Pn,V,null),t(V,id),t(V,Yo),t(V,dd),t(V,Oe),m(Qn,Oe,null),t(Oe,ld),t(Oe,Jo),g(e,Zr,i),m(Ln,e,i),g(e,ea,i),g(e,dr,i),ta=!0},p(e,[i]){const U={};i&2&&(U.$$scope={dirty:i,ctx:e}),Y.$set(U)},i(e){ta||(c(Re.$$.fragment,e),c(Y.$$.fragment,e),c(Ue.$$.fragment,e),c(Ye.$$.fragment,e),c(Je.$$.fragment,e),c(Xe.$$.fragment,e),c(Ke.$$.fragment,e),c(Ze.$$.fragment,e),c(et.$$.fragment,e),c(tt.$$.fragment,e),c(nt.$$.fragment,e),c(ot.$$.fragment,e),c(rt.$$.fragment,e),c(at.$$.fragment,e),c(st.$$.fragment,e),c(it.$$.fragment,e),c(dt.$$.fragment,e),c(lt.$$.fragment,e),c(mt.$$.fragment,e),c(ct.$$.fragment,e),c(ft.$$.fragment,e),c(pt.$$.fragment,e),c(ut.$$.fragment,e),c(gt.$$.fragment,e),c(ht.$$.fragment,e),c(_t.$$.fragment,e),c(bt.$$.fragment,e),c(vt.$$.fragment,e),c($t.$$.fragment,e),c(yt.$$.fragment,e),c(xt.$$.fragment,e),c(qt.$$.fragment,e),c(Ct.$$.fragment,e),c(zt.$$.fragment,e),c(wt.$$.fragment,e),c(Tt.$$.fragment,e),c(kt.$$.fragment,e),c(Pt.$$.fragment,e),c(Qt.$$.fragment,e),c(Lt.$$.fragment,e),c(Ht.$$.fragment,e),c(At.$$.fragment,e),c(Dt.$$.fragment,e),c(Mt.$$.fragment,e),c(Ft.$$.fragment,e),c(Nt.$$.fragment,e),c(Et.$$.fragment,e),c(It.$$.fragment,e),c(Vt.$$.fragment,e),c(Gt.$$.fragment,e),c(Bt.$$.fragment,e),c(Ot.$$.fragment,e),c(St.$$.fragment,e),c(Rt.$$.fragment,e),c(jt.$$.fragment,e),c(Wt.$$.fragment,e),c(Ut.$$.fragment,e),c(Yt.$$.fragment,e),c(Jt.$$.fragment,e),c(Xt.$$.fragment,e),c(Kt.$$.fragment,e),c(Zt.$$.fragment,e),c(en.$$.fragment,e),c(tn.$$.fragment,e),c(nn.$$.fragment,e),c(on.$$.fragment,e),c(rn.$$.fragment,e),c(an.$$.fragment,e),c(sn.$$.fragment,e),c(dn.$$.fragment,e),c(ln.$$.fragment,e),c(mn.$$.fragment,e),c(cn.$$.fragment,e),c(fn.$$.fragment,e),c(pn.$$.fragment,e),c(un.$$.fragment,e),c(gn.$$.fragment,e),c(hn.$$.fragment,e),c(_n.$$.fragment,e),c(bn.$$.fragment,e),c(vn.$$.fragment,e),c($n.$$.fragment,e),c(yn.$$.fragment,e),c(xn.$$.fragment,e),c(Cn.$$.fragment,e),c(zn.$$.fragment,e),c(wn.$$.fragment,e),c(Tn.$$.fragment,e),c(kn.$$.fragment,e),c(Pn.$$.fragment,e),c(Qn.$$.fragment,e),c(Ln.$$.fragment,e),ta=!0)},o(e){f(Re.$$.fragment,e),f(Y.$$.fragment,e),f(Ue.$$.fragment,e),f(Ye.$$.fragment,e),f(Je.$$.fragment,e),f(Xe.$$.fragment,e),f(Ke.$$.fragment,e),f(Ze.$$.fragment,e),f(et.$$.fragment,e),f(tt.$$.fragment,e),f(nt.$$.fragment,e),f(ot.$$.fragment,e),f(rt.$$.fragment,e),f(at.$$.fragment,e),f(st.$$.fragment,e),f(it.$$.fragment,e),f(dt.$$.fragment,e),f(lt.$$.fragment,e),f(mt.$$.fragment,e),f(ct.$$.fragment,e),f(ft.$$.fragment,e),f(pt.$$.fragment,e),f(ut.$$.fragment,e),f(gt.$$.fragment,e),f(ht.$$.fragment,e),f(_t.$$.fragment,e),f(bt.$$.fragment,e),f(vt.$$.fragment,e),f($t.$$.fragment,e),f(yt.$$.fragment,e),f(xt.$$.fragment,e),f(qt.$$.fragment,e),f(Ct.$$.fragment,e),f(zt.$$.fragment,e),f(wt.$$.fragment,e),f(Tt.$$.fragment,e),f(kt.$$.fragment,e),f(Pt.$$.fragment,e),f(Qt.$$.fragment,e),f(Lt.$$.fragment,e),f(Ht.$$.fragment,e),f(At.$$.fragment,e),f(Dt.$$.fragment,e),f(Mt.$$.fragment,e),f(Ft.$$.fragment,e),f(Nt.$$.fragment,e),f(Et.$$.fragment,e),f(It.$$.fragment,e),f(Vt.$$.fragment,e),f(Gt.$$.fragment,e),f(Bt.$$.fragment,e),f(Ot.$$.fragment,e),f(St.$$.fragment,e),f(Rt.$$.fragment,e),f(jt.$$.fragment,e),f(Wt.$$.fragment,e),f(Ut.$$.fragment,e),f(Yt.$$.fragment,e),f(Jt.$$.fragment,e),f(Xt.$$.fragment,e),f(Kt.$$.fragment,e),f(Zt.$$.fragment,e),f(en.$$.fragment,e),f(tn.$$.fragment,e),f(nn.$$.fragment,e),f(on.$$.fragment,e),f(rn.$$.fragment,e),f(an.$$.fragment,e),f(sn.$$.fragment,e),f(dn.$$.fragment,e),f(ln.$$.fragment,e),f(mn.$$.fragment,e),f(cn.$$.fragment,e),f(fn.$$.fragment,e),f(pn.$$.fragment,e),f(un.$$.fragment,e),f(gn.$$.fragment,e),f(hn.$$.fragment,e),f(_n.$$.fragment,e),f(bn.$$.fragment,e),f(vn.$$.fragment,e),f($n.$$.fragment,e),f(yn.$$.fragment,e),f(xn.$$.fragment,e),f(Cn.$$.fragment,e),f(zn.$$.fragment,e),f(wn.$$.fragment,e),f(Tn.$$.fragment,e),f(kn.$$.fragment,e),f(Pn.$$.fragment,e),f(Qn.$$.fragment,e),f(Ln.$$.fragment,e),ta=!1},d(e){e&&(s(Se),s(P),s(Hn),s(mr),s(je),s(cr),s(We),s(fr),s(pr),s(ur),s(Q),s(gr),s(hr),s(L),s(_r),s(br),s(H),s(vr),s($r),s(A),s(yr),s(xr),s(D),s(qr),s(Cr),s(z),s(zr),s(wr),s(y),s(Tr),s(kr),s(v),s(Pr),s(Qr),s(M),s(Lr),s(Hr),s(w),s(Ar),s(Dr),s(j),s(Mr),s(Fr),s(W),s(Nr),s(Er),s(T),s(Ir),s(Vr),s(k),s(Gr),s(Br),s(F),s(Or),s(Sr),s(N),s(Rr),s(jr),s(E),s(Wr),s(Ur),s(qn),s(Yr),s(Jr),s(I),s(Xr),s(Kr),s(V),s(Zr),s(ea),s(dr)),s(q),p(Re,e),p(Y,e),p(Ue,e),p(Ye),p(Je),p(Xe,e),p(Ke),p(Ze),p(et,e),p(tt),p(nt),p(ot,e),p(rt),p(at),p(st,e),p(it),p(dt),p(lt,e),p(mt),p(ct),p(ft),p(pt),p(ut,e),p(gt),p(ht),p(_t),p(bt),p(vt),p($t,e),p(yt),p(xt),p(qt),p(Ct),p(zt),p(wt),p(Tt),p(kt),p(Pt),p(Qt),p(Lt),p(Ht),p(At),p(Dt),p(Mt),p(Ft),p(Nt),p(Et),p(It),p(Vt),p(Gt),p(Bt),p(Ot,e),p(St),p(Rt),p(jt,e),p(Wt),p(Ut),p(Yt),p(Jt),p(Xt,e),p(Kt),p(Zt,e),p(en),p(tn,e),p(nn),p(on),p(rn),p(an),p(sn,e),p(dn),p(ln),p(mn),p(cn),p(fn),p(pn,e),p(un),p(gn),p(hn,e),p(_n),p(bn),p(vn,e),p($n),p(yn),p(xn,e),p(Cn),p(zn,e),p(wn),p(Tn),p(kn,e),p(Pn),p(Qn),p(Ln,e)}}}const Vl='{"title":"Quantization","local":"quantization","sections":[{"title":"QuantoConfig","local":"transformers.QuantoConfig","sections":[],"depth":2},{"title":"AqlmConfig","local":"transformers.AqlmConfig","sections":[],"depth":2},{"title":"VptqConfig","local":"transformers.VptqConfig","sections":[],"depth":2},{"title":"AwqConfig","local":"transformers.AwqConfig","sections":[],"depth":2},{"title":"EetqConfig","local":"transformers.EetqConfig","sections":[],"depth":2},{"title":"GPTQConfig","local":"transformers.GPTQConfig","sections":[],"depth":2},{"title":"BitsAndBytesConfig","local":"transformers.BitsAndBytesConfig","sections":[],"depth":2},{"title":"HfQuantizer","local":"transformers.quantizers.HfQuantizer","sections":[],"depth":2},{"title":"HiggsConfig","local":"transformers.HiggsConfig","sections":[],"depth":2},{"title":"HqqConfig","local":"transformers.HqqConfig","sections":[],"depth":2},{"title":"Mxfp4Config","local":"transformers.Mxfp4Config","sections":[],"depth":2},{"title":"FbgemmFp8Config","local":"transformers.FbgemmFp8Config","sections":[],"depth":2},{"title":"CompressedTensorsConfig","local":"transformers.CompressedTensorsConfig","sections":[],"depth":2},{"title":"TorchAoConfig","local":"transformers.TorchAoConfig","sections":[],"depth":2},{"title":"BitNetQuantConfig","local":"transformers.BitNetQuantConfig","sections":[],"depth":2},{"title":"SpQRConfig","local":"transformers.SpQRConfig","sections":[],"depth":2},{"title":"FineGrainedFP8Config","local":"transformers.FineGrainedFP8Config","sections":[],"depth":2},{"title":"QuarkConfig","local":"transformers.QuarkConfig","sections":[],"depth":2},{"title":"FPQuantConfig","local":"transformers.FPQuantConfig","sections":[],"depth":2},{"title":"AutoRoundConfig","local":"transformers.AutoRoundConfig","sections":[],"depth":2}],"depth":1}';function Gl(lr){return Ll(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Wl extends Al{constructor(q){super(),Dl(this,q,Gl,Il,Ql,{})}}export{Wl as component};
